<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scan to PDF — PDF Chamber</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<!-- CDNs -->
<script src="https://docs.opencv.org/4.7.0/opencv.js"></script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script src="https://unpkg.com/sortablejs@1.15.0/Sortable.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
<script src="https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>

<style>
:root {
  --focus:#00AEEF;
  --transition:all 0.3s ease;
  --bg-gradient:linear-gradient(135deg,#E3F2FD 0%,#BBDEFB 50%,#90CAF9 100%);
  --header-bg:#0a8b65;
  --card-bg:#ffffff;
  --text-primary:#002B5B;
  --text-secondary:#455A64;
  --btn-green:#0a8b65;
  --btn-hover:#087555;
  --footer-bg:#0a8b65;
  --footer-text:#ECEFF1;
  --border-upload:#0a8b65;
}
[data-theme="dark"] {
  --bg-gradient:linear-gradient(135deg,#0D1B2A 0%,#1B263B 50%,#415A77 100%);
  --header-bg:#0a8b65;
  --card-bg:#1B263B;
  --text-primary:#E0E1DD;
  --text-secondary:#AAB4BE;
  --btn-green:#0a8b65;
  --btn-hover:#0b7050;
  --footer-bg:#0a8b65;
  --footer-text:#E0E1DD;
  --border-upload:#0a8b65;
}

/* basic reset */
*,*::before,*::after { box-sizing: border-box; margin:0; padding:0; }
html,body{height:100%}
body {
  font-family:'Inter',sans-serif;
  background:var(--bg-gradient);
  color:var(--text-primary);
  min-height:100vh;
  display:flex;
  flex-direction:column;
}

/* Header (matches merge-pdf.html) */
header {
  background:var(--header-bg);
  color:#fff;
  padding:1rem 5%;
  display:flex;
  justify-content:space-between;
  align-items:center;
}
.logo {
  display:flex;
  align-items:center;
  gap:.75rem;
  font-weight:700;
  font-size:1.8rem;
  color:#fff;
  text-decoration:none;
}
.logo svg {width:40px;height:40px;fill:#fff;}
.theme-toggle {
  width:56px;
  height:30px;
  background:rgba(255,255,255,.15);
  border:2px solid #ffffff;
  border-radius:50px;
  position:relative;
  cursor:pointer;
}
.theme-toggle::before {
  content:'';
  position:absolute;
  top:3px;
  left:4px;
  width:20px;
  height:20px;
  background:#ffffff;
  border-radius:50%;
  transition:transform 0.3s;
}
[data-theme="dark"] .theme-toggle::before {
  transform:translateX(24px);
  background:#1B263B;
}

/* layout */
main{flex:1;max-width:1200px;margin:2rem auto;padding:0 5%;width:100%}
.grid{display:grid;grid-template-columns:1fr 380px;gap:1rem;align-items:start}
.card{background:var(--card-bg);border-radius:12px;padding:1rem;box-shadow:0 6px 18px rgba(2,40,60,.08)}

/* camera */
.camera-wrap{position:relative;border-radius:10px;overflow:hidden;background:#000;height:80vh;min-height:420px;display:flex;align-items:center;justify-content:center}
video#cameraView{width:100%;height:100%;object-fit:cover;display:block}
canvas#overlay{position:absolute;left:0;top:0;pointer-events:none}

/* controls & preview */
.controls{display:flex;flex-wrap:wrap;gap:.5rem;margin-top:.75rem;justify-content:space-between}
.btn{background:var(--btn-green);color:#fff;border:none;padding:.6rem 1rem;border-radius:8px;font-weight:600;cursor:pointer;transition:var(--transition)}
.btn:hover{background:var(--btn-hover);transform:scale(1.03)}
.toggle{background:rgba(255,255,255,0.9);padding:.45rem .75rem;border-radius:8px;border:2px solid #fff;cursor:pointer;font-weight:600}
.small{font-size:.95rem;color:var(--text-secondary);margin-top:.5rem}

/* preview list */
.preview-list{display:flex;flex-direction:column;gap:.5rem;max-height:62vh;overflow:auto;margin-top:.5rem}
.thumb{display:flex;align-items:center;gap:.5rem;padding:.5rem;border-radius:8px;background:var(--card-bg);border:1px solid rgba(0,0,0,.04)}
.thumb canvas{width:90px;height:auto;border-radius:6px}

/* modal cropper */
.modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);z-index:60}
.modal.show{display:flex}
.modal .modal-card{background:var(--card-bg);border-radius:10px;width:min(980px,95%);height:min(90vh,90%);padding:12px;display:flex;flex-direction:column;gap:8px}
.img-wrap{flex:1;overflow:auto;display:flex;align-items:center;justify-content:center}

/* onboarding */
.onboard-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:100}
.onboard-card{width:min(720px,92%);background:var(--card-bg);border-radius:12px;padding:18px;box-shadow:0 8px 30px rgba(0,0,0,0.4);color:var(--text-primary);display:flex;flex-direction:column;gap:10px}
.onboard-steps{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:6px}
.onboard-step{min-width:12px;height:12px;border-radius:50%;background:#eee}
.onboard-step.active{background:var(--btn-green)}
.onboard-hero img{width:120px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.08);background:#f7f9fc}
.onboard-controls{display:flex;gap:8px;justify-content:flex-end;margin-top:8px}

/* desktop QR card */
.desktop-qr{display:flex;flex-direction:column;align-items:center;gap:12px;padding:18px;text-align:center}
.qr-canvas{width:220px;height:220px;background:#fff;padding:10px;border-radius:8px;box-shadow:0 8px 18px rgba(0,0,0,.08)}

.footer{background:var(--footer-bg);color:var(--footer-text);text-align:center;padding:1.25rem 5%;margin-top:1rem;border-top-left-radius:8px;border-top-right-radius:8px}

/* small screens: mobile full-screen scanner layout (show camera full width) */
@media (max-width:900px){
  .grid{grid-template-columns:1fr}
  .camera-wrap{height:78vh;min-height:520px}
  .desktop-only{display:none}
  .onboard-overlay .onboard-card{width:92%}
}
</style>
</head>
<body>
<header>
  <a href="index.html" class="logo">
    <svg viewBox="0 0 24 24"><path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"/></svg>
    PDF Chamber
  </a>
  <div class="theme-toggle" id="themeToggle" title="Toggle theme"></div>
</header>

<main>
  <div class="grid">
    <!-- left: camera or desktop hint -->
    <section id="leftCard" class="card">
      <div id="mobileScanner" style="display:none">
        <div class="camera-wrap" id="cameraWrap">
          <video id="cameraView" autoplay playsinline></video>
          <canvas id="overlay"></canvas>
        </div>

        <div class="controls" style="margin-top:.8rem;">
          <div style="display:flex;gap:.5rem;flex-wrap:wrap">
            <button class="btn" id="startCam">Open Camera</button>
            <button class="btn" id="modeToggle">Auto-Capture: On</button>
            <button class="btn" id="captureBtn">Tap to Capture</button>
            <label class="toggle" id="uploadLabel">Choose Images<input id="fileInput" type="file" accept="image/*" multiple hidden></label>
          </div>

          <div style="display:flex;gap:.5rem;flex-wrap:wrap">
            <button class="btn" id="scanNext" disabled>Confirm & Scan Next</button>
            <button class="btn" id="generatePdf" disabled>Generate PDF</button>
            <button class="btn" id="sharePdf" disabled>Share PDF</button>
          </div>
        </div>

        <div class="small">Filters & Enhancements</div>
        <div class="controls" style="justify-content:flex-start;margin-top:.5rem;">
          <button class="btn" id="autoEnhance">Auto-Enhance</button>
          <button class="btn filter-btn active" data-filter="original">Original</button>
          <button class="btn filter-btn" data-filter="auto">Auto Color</button>
          <button class="btn filter-btn" data-filter="light">Light Text</button>
          <button class="btn filter-btn" data-filter="gray">Grayscale</button>
          <button class="btn filter-btn" data-filter="binarize">B&W</button>
        </div>

        <div class="row" style="margin-top:.75rem;">
          <div class="small">Brightness</div>
          <input id="brightness" type="range" min="0" max="200" value="100">
          <div class="small">Contrast</div>
          <input id="contrast" type="range" min="0" max="200" value="100">
        </div>

        <div class="row" style="margin-top:.5rem;align-items:center;">
          <label class="small"><input type="checkbox" id="searchablePdf"> Make searchable (OCR)</label>
          <label class="small"><input type="checkbox" id="deskew"> Auto-deskew</label>
          <label class="small"><input type="checkbox" id="shadowRemove"> Reduce shadows</label>
          <label class="small">Output:
            <select id="pdfSize"><option value="auto">Auto</option><option value="A4">A4</option><option value="Letter">Letter</option></select>
          </label>
          <label class="small">JPEG Quality <input id="jpegQuality" type="range" min="0.5" max="1" step="0.05" value="0.95"></label>
        </div>

        <div class="small" style="margin-top:.75rem;color:var(--text-secondary)">Tip: Use Auto-Capture for hands-free scanning. After capture you can fine-tune crop in the full-screen editor.</div>
      </div>

      <!-- Desktop hint -->
      <div id="desktopHint" class="desktop-only" style="display:none">
        <div style="display:flex;align-items:center;gap:12px">
          <div style="flex:1">
            <h2 style="margin:0 0 .4rem 0">Scan with your phone</h2>
            <p class="small" style="margin-bottom:8px">Open this page on your mobile device to access the full scanner interface. Scan the QR code with your phone camera or any QR app.</p>
            <ol class="small" style="padding-left:1rem">
              <li>Open your phone camera.</li>
              <li>Point it at the QR code.</li>
              <li>Tap the notification to open the scanner on your phone.</li>
            </ol>
            <div style="margin-top:.75rem">
              <label class="toggle">Upload images from desktop<input id="desktopFile" type="file" accept="image/*" multiple hidden style="display:none"></label>
              <button class="btn" id="desktopUploadBtn" style="margin-left:.5rem">Upload</button>
            </div>
          </div>

          <div style="width:240px">
            <div class="desktop-qr card">
              <canvas id="qrCanvas" class="qr-canvas"></canvas>
              <div class="small">Scan this with your phone camera</div>
              <div style="margin-top:8px">
                <button class="btn" id="copyLinkBtn">Copy Link</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- right column: pages list & actions -->
    <aside class="card">
      <h3 style="margin:0 0 .5rem 0">Scanned Pages</h3>
      <div class="small" style="margin-bottom:.5rem">Drag to reorder. Edit / Delete or Save project locally.</div>
      <div id="pageList" class="preview-list" aria-live="polite"></div>

      <div class="controls" style="margin-top:.5rem;justify-content:flex-start;">
        <button class="btn" id="saveProject">Save Project</button>
        <button class="btn" id="loadProject">Load Project</button>
        <button class="btn" id="exportBtn" disabled>Export PDF</button>
        <button class="btn" id="shareBtn" disabled>Share PDF</button>
        <button class="btn" id="clearAll">Clear</button>
      </div>
    </aside>
  </div>
</main>

<!-- Cropper modal -->
<div id="cropModal" class="modal" role="dialog" aria-modal="true">
  <div class="modal-card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small">Adjust corners & crop</div>
      <div style="display:flex;gap:.5rem">
        <button class="btn" id="retakeBtn">Retake</button>
        <button class="btn" id="confirmCrop">Confirm</button>
      </div>
    </div>

    <div class="img-wrap">
      <img id="cropImage" style="max-width:100%;display:block;margin:0 auto" alt="Crop preview">
    </div>

    <div style="display:flex;gap:.5rem;justify-content:flex-end">
      <button class="btn" id="scanNextModal">Confirm & Scan Next</button>
      <button class="btn" id="generateModal">Generate PDF</button>
    </div>
  </div>
</div>

<!-- Onboarding -->
<div id="onboard" class="onboard-overlay" aria-hidden="true">
  <div class="onboard-card" role="dialog" aria-modal="true" aria-label="Quick tour">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700;font-size:1.1rem">Welcome to PDF Chamber — Scan to PDF</div>
      <div style="font-size:.9rem;color:var(--text-secondary)"><button id="onboardSkip" class="btn">Skip</button></div>
    </div>

    <div style="display:flex;gap:12px;align-items:center">
      <div class="onboard-hero">
        <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='240' height='160' viewBox='0 0 240 160'><rect width='240' height='160' rx='12' fill='%23F7FBFF'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='%23002B5B' font-family='Inter,Arial' font-size='14'>Scan • Enhance • Export</text></svg>" alt="Scan demo">
      </div>
      <div style="flex:1">
        <ol style="padding-left:1rem">
          <li><strong>Open Camera</strong> — tap <em>Open Camera</em> to use your device camera (back camera preferred).</li>
          <li><strong>Auto-capture</strong> detects document edges automatically; hold steady to capture hands-free.</li>
          <li><strong>Edit & enhance</strong> after capture — crop, rotate, apply filters, adjust brightness/contrast.</li>
          <li><strong>Make searchable</strong> by enabling OCR, then export a high-quality searchable PDF.</li>
        </ol>
        <div class="onboard-steps" id="onboardSteps">
          <div class="onboard-step active"></div>
          <div class="onboard-step"></div>
          <div class="onboard-step"></div>
        </div>
      </div>
    </div>

    <div class="onboard-controls">
      <button id="onboardPrev" class="btn" style="display:none">Back</button>
      <button id="onboardNext" class="btn">Next</button>
      <button id="onboardDone" class="btn" style="display:none">Done</button>
    </div>
  </div>
</div>

<footer class="footer">© 2025 PDF Chamber. All rights reserved.</footer>

<script>
/* ================== CONFIG ================== */
const TESS_LANGS = 'eng+spa+fra+deu+ita+por+hin+chi_sim+jpn+kor';
const TESS_OPTIONS = { logger: m => console.log('Tesseract:', m) };

/* ================== STATE & ELEMENTS ================== */
let stream = null;
let cvReady = false;
let processing = false;
let stabilityCounter = 0;
let lastContour = null;
let cropper = null;
let tessWorker = null;
let tessLoading = false;

const video = document.getElementById('cameraView');
const overlay = document.getElementById('overlay');
const pageList = document.getElementById('pageList');
let pages = []; // { canvas, url, width, height, ocrWords }

let lastPdfBlob = null; // stores last generated PDF Blob so Share can reuse it

function onOpenCvReady(){ cvReady = true; console.log('OpenCV ready'); }
if(window.cv && cv['onRuntimeInitialized']) cv['onRuntimeInitialized'] = onOpenCvReady;

/* Theme toggle like merge-pdf.html */
const themeToggle = document.getElementById('themeToggle');
const html = document.documentElement;
if(localStorage.theme === 'dark' || (!localStorage.theme && window.matchMedia('(prefers-color-scheme:dark)').matches)) html.dataset.theme = 'dark';
themeToggle.addEventListener('click', ()=> { html.dataset.theme = html.dataset.theme === 'dark' ? 'light' : 'dark'; localStorage.theme = html.dataset.theme; });

/* Resize overlay */
function resizeOverlay(){ overlay.width = video.clientWidth; overlay.height = video.clientHeight; overlay.style.left = video.offsetLeft + 'px'; overlay.style.top = video.offsetTop + 'px'; }
window.addEventListener('resize', resizeOverlay);

/* ================== Device detection (mobile vs desktop) ================== */
function isMobileDevice(){
  const touch = ('maxTouchPoints' in navigator && navigator.maxTouchPoints > 0) || 'ontouchstart' in window;
  const narrow = window.innerWidth <= 900;
  const ua = navigator.userAgent || '';
  const mobileUa = /Android|iPhone|iPad|iPod|IEMobile|Mobile|webOS/i.test(ua);
  return (touch && narrow) || mobileUa;
}

/* Toggle UI based on device */
const mobileScanner = document.getElementById('mobileScanner');
const desktopHint = document.getElementById('desktopHint');
function applyDeviceLayout(){
  if(isMobileDevice()){
    mobileScanner.style.display = 'block';
    desktopHint.style.display = 'none';
    maybeShowOnboarding();
  } else {
    mobileScanner.style.display = 'none';
    desktopHint.style.display = 'block';
    generateQR(window.location.href);
  }
}
applyDeviceLayout();
window.addEventListener('resize', ()=> { applyDeviceLayout(); });

/* ================== Onboarding (mobile only) ================== */
const ONBOARD_KEY = 'pdf_chamber_onboard_done';
const onboard = document.getElementById('onboard');
const onboardNext = document.getElementById('onboardNext');
const onboardPrev = document.getElementById('onboardPrev');
const onboardDone = document.getElementById('onboardDone');
const onboardSkip = document.getElementById('onboardSkip');
const onboardSteps = Array.from(document.querySelectorAll('.onboard-step'));
let onboardIndex = 0;

function maybeShowOnboarding(){
  try {
    if(!isMobileDevice()) return;
    if(localStorage.getItem(ONBOARD_KEY)) return;
    onboard.style.display = 'flex';
    updateOnboardUI();
  } catch(e) { onboard.style.display = 'flex'; updateOnboardUI(); }
}
function updateOnboardUI(){
  onboardSteps.forEach((s,i)=> s.classList.toggle('active', i===onboardIndex));
  onboardPrev.style.display = onboardIndex>0 ? 'inline-block' : 'none';
  onboardNext.style.display = onboardIndex < onboardSteps.length-1 ? 'inline-block' : 'none';
  onboardDone.style.display = onboardIndex === onboardSteps.length-1 ? 'inline-block' : 'none';
}
onboardNext.addEventListener('click', ()=> { onboardIndex = Math.min(onboardSteps.length-1, onboardIndex+1); updateOnboardUI(); });
onboardPrev.addEventListener('click', ()=> { onboardIndex = Math.max(0, onboardIndex-1); updateOnboardUI(); });
onboardDone.addEventListener('click', ()=> { localStorage.setItem(ONBOARD_KEY, '1'); onboard.style.display = 'none'; });
onboardSkip.addEventListener('click', ()=> { localStorage.setItem(ONBOARD_KEY, '1'); onboard.style.display = 'none'; });

/* ================== QR generation (desktop) ================== */
function generateQR(text){
  try {
    const qrCanvas = document.getElementById('qrCanvas');
    const qr = new QRious({ element: qrCanvas, value: text, size: 220, background: '#fff', foreground: '#000' });
    document.getElementById('copyLinkBtn').onclick = async () => {
      try { await navigator.clipboard.writeText(text); alert('Link copied to clipboard'); } catch(e){ prompt('Copy this link', text); }
    };
  } catch(e){ console.warn('QR generation failed', e); }
}

/* desktop upload hooking */
document.getElementById('desktopUploadBtn').addEventListener('click', ()=> document.getElementById('desktopFile').click());
document.getElementById('desktopFile').addEventListener('change', async (e)=>{
  for(const f of e.target.files){
    const url = URL.createObjectURL(f); await handleImageUpload(url); URL.revokeObjectURL(url);
  }
});

/* ================== Camera & edge detection (mobile) ================== */
document.getElementById('startCam').addEventListener('click', async ()=> {
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal:1280 }, height: { ideal:720 } }, audio:false });
    video.srcObject = stream; await video.play(); resizeOverlay(); startEdgeLoop();
  } catch(err) { alert('Camera error: ' + err.message); }
});

let autoCapture = true;
document.getElementById('modeToggle').addEventListener('click', ()=> {
  autoCapture = !autoCapture;
  document.getElementById('modeToggle').textContent = 'Auto-Capture: ' + (autoCapture ? 'On' : 'Off');
});

/* file upload wiring (mobile too) */
document.getElementById('uploadLabel').addEventListener('click', ()=> document.getElementById('fileInput').click());
document.getElementById('fileInput').addEventListener('change', async (e) => {
  for(const f of e.target.files){
    const url = URL.createObjectURL(f);
    await handleImageUpload(url);
    URL.revokeObjectURL(url);
  }
});

/* edge detection loop */
async function startEdgeLoop(){
  if(!cvReady) return;
  const off = document.createElement('canvas'); const oW = 320, oH = 240; off.width = oW; off.height = oH;
  const offCtx = off.getContext('2d'); const ctx = overlay.getContext('2d');
  processing = false; stabilityCounter = 0; lastContour = null;
  const loop = async () => {
    if(!video.videoWidth){ requestAnimationFrame(loop); return; }
    try {
      offCtx.drawImage(video, 0, 0, oW, oH);
      let src = cv.imread(off);
      let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      let edged = new cv.Mat(); cv.Canny(gray, edged, 75, 200);
      let contours = new cv.MatVector(); let hierarchy = new cv.Mat();
      cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best = null, maxA = 0;
      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i);
        const peri = cv.arcLength(cnt, true);
        const approx = new cv.Mat(); cv.approxPolyDP(cnt, approx, 0.02*peri, true);
        if(approx.rows === 4){
          const area = cv.contourArea(cnt);
          if(area > maxA){ maxA = area; best = approx; }
        }
      }
      ctx.clearRect(0,0,overlay.width, overlay.height);
      if(best){
        const pts = [];
        for(let i=0;i<4;i++) pts.push({ x: best.data32S[i*2] * (overlay.width/oW), y: best.data32S[i*2+1] * (overlay.height/oH) });
        drawPolygon(ctx, pts, 'lime');
        const polyStr = JSON.stringify(pts.map(p => Math.round(p.x) + ',' + Math.round(p.y)));
        if(polyStr === lastContour) stabilityCounter++; else { stabilityCounter = 0; lastContour = polyStr; }
        if(autoCapture && stabilityCounter > 6 && !processing){ processing = true; setTimeout(()=> captureFromVideo(), 120); }
      }
      src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete(); if(best) best.delete();
    } catch(err) { console.warn('edge loop', err); }
    requestAnimationFrame(loop);
  };
  requestAnimationFrame(loop);
}

function drawPolygon(ctx, pts, color){
  ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.closePath(); ctx.stroke(); ctx.fillStyle='rgba(0,255,0,0.06)'; ctx.fill();
}

/* capture */
document.getElementById('captureBtn').addEventListener('click', ()=> captureFromVideo());

async function captureFromVideo(){
  if(!video.videoWidth) return;
  const c = document.createElement('canvas'); c.width = video.videoWidth; c.height = video.videoHeight;
  c.getContext('2d').drawImage(video, 0, 0, c.width, c.height);
  if(cvReady){
    try {
      const src = cv.imread(c);
      let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      let edged = new cv.Mat(); cv.Canny(gray, edged, 75, 200);
      let contours = new cv.MatVector(); let hierarchy = new cv.Mat();
      cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best = null, maxA = 0;
      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i); const peri = cv.arcLength(cnt, true); const approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02*peri, true);
        if(approx.rows === 4){ const area = cv.contourArea(cnt); if(area > maxA){ maxA = area; best = approx; } }
      }
      if(best){
        const pts = []; for(let i=0;i<4;i++) pts.push({ x: best.data32S[i*2], y: best.data32S[i*2+1] });
        pts.sort((a,b)=>a.y-b.y);
        const top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
        const bottom = pts.slice(2,4).sort((a,b)=>a.x-b.x);
        const ordered = [ top[0], top[1], bottom[1], bottom[0] ];
        const widthTop = Math.hypot(ordered[0].x-ordered[1].x, ordered[0].y-ordered[1].y);
        const widthBottom = Math.hypot(ordered[3].x-ordered[2].x, ordered[3].y-ordered[2].y);
        const maxW = Math.max(widthTop, widthBottom);
        const heightLeft = Math.hypot(ordered[0].x-ordered[3].x, ordered[0].y-ordered[3].y);
        const heightRight = Math.hypot(ordered[1].x-ordered[2].x, ordered[1].y-ordered[2].y);
        const maxH = Math.max(heightLeft, heightRight);

        const srcCoords = cv.matFromArray(4,1,cv.CV_32FC2, [ ordered[0].x, ordered[0].y, ordered[1].x, ordered[1].y, ordered[2].x, ordered[2].y, ordered[3].x, ordered[3].y ]);
        const dstCoords = cv.matFromArray(4,1,cv.CV_32FC2, [ 0,0, maxW-1,0, maxW-1, maxH-1, 0, maxH-1 ]);
        const M = cv.getPerspectiveTransform(srcCoords, dstCoords);
        const dst = new cv.Mat(); const dsize = new cv.Size(Math.round(maxW), Math.round(maxH));
        cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
        const outCanvas = document.createElement('canvas'); outCanvas.width = dst.cols; outCanvas.height = dst.rows; cv.imshow(outCanvas, dst);
        showCropModal(outCanvas.toDataURL('image/jpeg'));
        src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete(); if(best) best.delete(); srcCoords.delete(); dstCoords.delete(); M.delete(); dst.delete();
        return;
      }
      src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete();
    } catch(err) { console.warn('auto-crop error', err); }
  }
  showCropModal(c.toDataURL('image/jpeg'));
}

/* Crop modal */
const cropModal = document.getElementById('cropModal');
const cropImage = document.getElementById('cropImage');

function showCropModal(dataUrl){
  cropImage.src = dataUrl;
  cropModal.classList.add('show');
  setTimeout(()=>{ if(cropper) cropper.destroy(); cropper = new Cropper(cropImage, { viewMode:1, autoCropArea:1, background:false, responsive:true, movable:true, zoomable:true, rotatable:true }); }, 150);
}

document.getElementById('retakeBtn').addEventListener('click', ()=> { cropModal.classList.remove('show'); if(cropper){ cropper.destroy(); cropper=null; } });

async function finalizeCropAndAdd(){
  if(!cropper) return;
  const c = cropper.getCroppedCanvas();
  const processed = await applyEnhancementsToCanvas(c);

  let ocrWords = null;
  if(document.getElementById('searchablePdf').checked){
    try { ocrWords = await doClientOCR(processed); } catch(err){ console.warn('OCR failed', err); ocrWords = null; }
  }

  pages.push({ canvas: processed, url: processed.toDataURL('image/jpeg', parseFloat(document.getElementById('jpegQuality').value)), width: processed.width, height: processed.height, ocrWords });
  renderPages();
  cropModal.classList.remove('show');
  if(cropper){ cropper.destroy(); cropper = null; }
  document.getElementById('scanNext').disabled = false;
  document.getElementById('generatePdf').disabled = false;
  document.getElementById('exportBtn').disabled = false;
  document.getElementById('shareBtn').disabled = false;
  document.getElementById('sharePdf').disabled = false;
}

document.getElementById('confirmCrop').addEventListener('click', finalizeCropAndAdd);
document.getElementById('scanNextModal').addEventListener('click', async ()=>{ await finalizeCropAndAdd(); cropModal.classList.remove('show'); startEdgeLoop(); });
document.getElementById('generateModal').addEventListener('click', async ()=>{ await finalizeCropAndAdd(); await generatePDF({download:true}); });

/* Enhancements */
async function applyEnhancementsToCanvas(srcCanvas){
  const tmp = document.createElement('canvas'); tmp.width = srcCanvas.width; tmp.height = srcCanvas.height;
  const ctx = tmp.getContext('2d'); ctx.drawImage(srcCanvas, 0, 0);

  if(document.getElementById('shadowRemove')?.checked){
    const imgd = ctx.getImageData(0,0,tmp.width,tmp.height); const d = imgd.data;
    for(let i=0;i<d.length;i+=4){ d[i]=Math.pow(d[i]/255,0.9)*255; d[i+1]=Math.pow(d[i+1]/255,0.9)*255; d[i+2]=Math.pow(d[i+2]/255,0.9)*255; }
    ctx.putImageData(imgd, 0, 0);
  }

  if(document.getElementById('autoEnhance').classList.contains('active')){
    const imgd = ctx.getImageData(0,0,tmp.width,tmp.height); const d = imgd.data;
    let min=255, max=0; for(let i=0;i<d.length;i+=4){ const v=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]; if(v<min)min=v; if(v>max)max=v; }
    const scale = 255/(max-min || 1);
    for(let i=0;i<d.length;i+=4){ d[i]=Math.max(0,Math.min(255,Math.round((d[i]-min)*scale))); d[i+1]=Math.max(0,Math.min(255,Math.round((d[i+1]-min)*scale))); d[i+2]=Math.max(0,Math.min(255,Math.round((d[i+2]-min)*scale))); }
    ctx.putImageData(imgd, 0, 0);
  }

  const activeFilter = document.querySelector('.filter-btn.active')?.dataset.filter || 'original';
  if(activeFilter !== 'original'){
    const imgd = ctx.getImageData(0,0,tmp.width,tmp.height); const d = imgd.data;
    for(let i=0;i<d.length;i+=4){
      let r=d[i], g=d[i+1], b=d[i+2];
      if(activeFilter === 'gray'){ const v=0.299*r+0.587*g+0.114*b; r=g=b=v; }
      else if(activeFilter === 'binarize'){ const v=0.299*r+0.587*g+0.114*b; const t=128; r=g=b=(v>t?255:0); }
      else if(activeFilter === 'light'){ const v=0.299*r+0.587*g+0.114*b; r=g=b=v*1.15; }
      else if(activeFilter === 'auto'){ r=(r-128)*1.05+128; g=(g-128)*1.05+128; b=(b-128)*1.05+128; }
      d[i]=Math.max(0,Math.min(255,Math.round(r))); d[i+1]=Math.max(0,Math.min(255,Math.round(g))); d[i+2]=Math.max(0,Math.min(255,Math.round(b)));
    }
    ctx.putImageData(imgd, 0, 0);
  }

  const bright = parseInt(document.getElementById('brightness').value)/100;
  const cont = parseInt(document.getElementById('contrast').value)/100;
  if(bright !== 1 || cont !== 1){
    const imgd = ctx.getImageData(0,0,tmp.width,tmp.height); const d = imgd.data;
    for(let i=0;i<d.length;i+=4){
      let r=d[i], g=d[i+1], b=d[i+2];
      r = (r - 128) * cont + 128; g = (g - 128) * cont + 128; b = (b - 128) * cont + 128;
      r *= bright; g *= bright; b *= bright;
      d[i] = Math.max(0, Math.min(255, Math.round(r))); d[i+1] = Math.max(0, Math.min(255, Math.round(g))); d[i+2] = Math.max(0, Math.min(255, Math.round(b)));
    }
    ctx.putImageData(imgd, 0, 0);
  }

  if(document.getElementById('deskew')?.checked && cvReady){
    try{
      const mCanvas = document.createElement('canvas'); mCanvas.width = tmp.width; mCanvas.height = tmp.height; mCanvas.getContext('2d').drawImage(tmp,0,0);
      let src = cv.imread(mCanvas); let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
      cv.threshold(gray,gray,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU);
      let lines = new cv.Mat(); cv.HoughLinesP(gray,lines,1,Math.PI/180,100,Math.min(tmp.width,tmp.height)/4,10);
      let angle=0,count=0;
      for(let i=0;i<lines.rows;i++){ let x1=lines.data32S[i*4], y1=lines.data32S[i*4+1], x2=lines.data32S[i*4+2], y2=lines.data32S[i*4+3]; let a=Math.atan2(y2-y1,x2-x1); angle+=a; count++; }
      if(count>0){ angle = angle/count; const deg = angle * 180 / Math.PI;
        const off=document.createElement('canvas'); off.width=tmp.width; off.height=tmp.height;
        const octx = off.getContext('2d'); octx.translate(tmp.width/2,tmp.height/2); octx.rotate(-deg * Math.PI/180); octx.drawImage(tmp, -tmp.width/2, -tmp.height/2);
        tmp.width = off.width; tmp.height = off.height; tmp.getContext('2d').drawImage(off,0,0);
      }
      src.delete(); gray.delete(); lines.delete();
    } catch(err){ console.warn('deskew failed', err); }
  }

  return tmp;
}

/* Client OCR using Tesseract (lazy load) */
async function ensureTesseractWorker(){
  if(tessWorker) return tessWorker;
  if(tessLoading){ while(tessLoading && !tessWorker) await new Promise(r=>setTimeout(r,200)); return tessWorker; }
  tessLoading = true;
  tessWorker = Tesseract.createWorker(TESS_OPTIONS);
  try{
    await tessWorker.load();
    await tessWorker.loadLanguage(TESS_LANGS);
    await tessWorker.initialize(TESS_LANGS);
    tessLoading = false;
    return tessWorker;
  } catch(err){
    tessLoading = false;
    tessWorker = null;
    console.error('Tesseract init failed', err);
    throw err;
  }
}
async function doClientOCR(canvas){
  const worker = await ensureTesseractWorker();
  const res = await worker.recognize(canvas.toDataURL('image/jpeg'));
  const words = (res?.data?.words || []).map(w => ({ text: w.text, bbox: { x0: w.bbox.x0, y0: w.bbox.y0, x1: w.bbox.x1, y1: w.bbox.y1 }, confidence: w.confidence }));
  return words;
}

/* Pages UI & Sortable */
function renderPages(){
  pageList.innerHTML = '';
  pages.forEach((p,i)=>{
    const div = document.createElement('div'); div.className = 'thumb'; div.dataset.index = i;
    const canvas = document.createElement('canvas'); canvas.width = p.canvas.width; canvas.height = p.canvas.height;
    canvas.getContext('2d').drawImage(p.canvas,0,0); canvas.style.width='110px';
    const info = document.createElement('div'); info.style.marginLeft='8px'; info.innerHTML = `<div style="font-weight:600">Page ${i+1}</div><div class="small">${p.width}×${p.height}</div>`;
    const actions = document.createElement('div'); actions.style.marginLeft='auto'; actions.style.display='flex'; actions.style.flexDirection='column'; actions.style.gap='6px';
    const edit = document.createElement('button'); edit.className='btn'; edit.textContent='Edit'; edit.addEventListener('click', ()=> showCropModal(p.canvas.toDataURL('image/jpeg')));
    const del = document.createElement('button'); del.className='btn'; del.textContent='Delete'; del.addEventListener('click', ()=> { pages.splice(i,1); renderPages(); });
    actions.appendChild(edit); actions.appendChild(del);
    div.appendChild(canvas); div.appendChild(info); div.appendChild(actions);
    pageList.appendChild(div);
  });

  Sortable.create(pageList, { animation:150, onEnd: (evt)=>{ const item = pages.splice(evt.oldIndex,1)[0]; pages.splice(evt.newIndex,0,item); renderPages(); }});
}

/* Generate searchable PDF
   options: { download: boolean } (download triggers automatic download)
   returns: Blob (pdf)
*/
async function generatePDF(options = { download: true }){
  if(pages.length===0) return alert('No pages to export');
  // build PDF
  const pdfDoc = await PDFLib.PDFDocument.create(); const font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
  const pdfSize = document.getElementById('pdfSize').value;
  for(const p of pages){
    const dataUrl = p.canvas.toDataURL('image/jpeg', parseFloat(document.getElementById('jpegQuality').value));
    const bytes = await (await fetch(dataUrl)).arrayBuffer();
    const img = await pdfDoc.embedJpg(bytes);
    let page;
    if(pdfSize==='A4'){ page = pdfDoc.addPage([595,842]); const ratio = Math.min(595/p.canvas.width, 842/p.canvas.height); const w=p.canvas.width*ratio, h=p.canvas.height*ratio; page.drawImage(img,{x:(595-w)/2,y:(842-h)/2,width:w,height:h}); }
    else if(pdfSize==='Letter'){ page = pdfDoc.addPage([612,792]); const ratio = Math.min(612/p.canvas.width, 792/p.canvas.height); const w=p.canvas.width*ratio, h=p.canvas.height*ratio; page.drawImage(img,{x:(612-w)/2,y:(792-h)/2,width:w,height:h}); }
    else { page = pdfDoc.addPage([p.canvas.width,p.canvas.height]); page.drawImage(img,{x:0,y:0,width:p.canvas.width,height:p.canvas.height}); }

    if(p.ocrWords && p.ocrWords.length){
      const scaleX = page.getWidth() / p.canvas.width; const scaleY = page.getHeight() / p.canvas.height;
      for(const w of p.ocrWords){ const x = w.bbox.x0 * scaleX; const y = page.getHeight() - (w.bbox.y1 * scaleY); page.drawText(w.text.replace(/\s+/g,' '), { x, y, size:10, font, color: PDFLib.rgb(1,1,1), opacity:0 }); }
    }
  }

  const pdfBytes = await pdfDoc.save();
  const blob = new Blob([pdfBytes], { type: 'application/pdf' });
  lastPdfBlob = blob; // save for sharing
  // enable share button(s)
  document.getElementById('shareBtn').disabled = false;
  const mobileShare = document.getElementById('sharePdf'); if(mobileShare) mobileShare.disabled = false;

  if(options.download){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `scanned-${new Date().toISOString().slice(0,10)}.pdf`; a.click();
    setTimeout(()=> URL.revokeObjectURL(url), 2000);
  }
  // return blob for further use
  return blob;
}

/* Share PDF using Web Share API Level 2 (files) with fallback to download */
async function sharePdfFile(){
  try {
    if(!lastPdfBlob){
      // generate PDF (no immediate download)
      await generatePDF({ download: false });
      // small delay for lastPdfBlob to set
    }
    if(!lastPdfBlob) return alert('Failed to create PDF for sharing.');

    const fileName = `scanned-${new Date().toISOString().slice(0,10)}.pdf`;
    const file = new File([lastPdfBlob], fileName, { type: 'application/pdf' });

    // navigator.canShare may not be available in all browsers
    if(navigator.canShare && navigator.canShare({ files: [file] })){
      await navigator.share({ files: [file], title: fileName, text: 'Scanned PDF from PDF Chamber' });
    } else if(navigator.share && navigator.canShare){ // try without files if it supports at least
      await navigator.share({ title: fileName, text: 'Scanned PDF (file attached may not be supported on this browser).' });
      // fallback to download
      const url = URL.createObjectURL(lastPdfBlob);
      const a = document.createElement('a'); a.href = url; a.download = fileName; a.click();
      setTimeout(()=> URL.revokeObjectURL(url),2000);
    } else if(navigator.share && !navigator.canShare){
      // some browsers support share but not canShare; try share() with text/url
      const url = URL.createObjectURL(lastPdfBlob);
      try { await navigator.share({ title: fileName, text: 'Scanned PDF', url }); } catch(e) {
        // fallback to download if share fails
        const a = document.createElement('a'); a.href = url; a.download = fileName; a.click(); setTimeout(()=> URL.revokeObjectURL(url),2000);
      }
    } else {
      // fallback: download
      const url = URL.createObjectURL(lastPdfBlob);
      const a = document.createElement('a'); a.href = url; a.download = fileName; a.click();
      setTimeout(()=> URL.revokeObjectURL(url),2000);
    }
  } catch(err){
    console.error('Share failed', err);
    // fallback - download
    if(lastPdfBlob){
      const url = URL.createObjectURL(lastPdfBlob);
      const a = document.createElement('a'); a.href = url; a.download = `scanned-${new Date().toISOString().slice(0,10)}.pdf`; a.click();
      setTimeout(()=> URL.revokeObjectURL(url),2000);
    } else {
      alert('Sharing failed: ' + err.message);
    }
  }
}

/* Buttons hooking for share */
document.getElementById('shareBtn').addEventListener('click', async ()=> {
  // ensure PDF exists; if not, generate and then share
  if(!lastPdfBlob) {
    document.getElementById('exportBtn').disabled = true;
    await generatePDF({ download: false });
    document.getElementById('exportBtn').disabled = false;
  }
  await sharePdfFile();
});
const mobileShareBtn = document.getElementById('sharePdf');
if(mobileShareBtn) mobileShareBtn.addEventListener('click', async ()=> {
  if(!lastPdfBlob) await generatePDF({ download: false });
  await sharePdfFile();
});

/* Save/Load Project */
document.getElementById('saveProject').addEventListener('click', async ()=>{
  const toSave = await Promise.all(pages.map(async p => ({ dataUrl: p.canvas.toDataURL('image/jpeg',0.9), width: p.width, height: p.height, ocrWords: p.ocrWords })));
  localStorage.setItem('scanProject', JSON.stringify(toSave));
  alert('Project saved locally');
});
document.getElementById('loadProject').addEventListener('click', async ()=>{
  const raw = localStorage.getItem('scanProject'); if(!raw) return alert('No saved project'); const arr = JSON.parse(raw); pages=[]; for(const it of arr){ const img = new Image(); img.src = it.dataUrl; await new Promise(r=>img.onload=r); const c = document.createElement('canvas'); c.width = it.width; c.height = it.height; c.getContext('2d').drawImage(img,0,0); pages.push({ canvas:c, url:it.dataUrl, width:it.width, height:it.height, ocrWords: it.ocrWords }); } renderPages(); alert('Project loaded');
});

/* Upload helper (auto-crop) */
async function handleImageUpload(url){
  const img = new Image(); img.crossOrigin='anonymous'; img.src = url; await new Promise(r=>img.onload=r);
  const c = document.createElement('canvas'); c.width = img.naturalWidth; c.height = img.naturalHeight; c.getContext('2d').drawImage(img,0,0);
  if(cvReady){
    try{
      const src = cv.imread(c); let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray,gray,new cv.Size(5,5),0);
      let edged = new cv.Mat(); cv.Canny(gray,edged,75,200);
      let contours = new cv.MatVector(); let hierarchy = new cv.Mat(); cv.findContours(edged,contours,hierarchy,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE);
      let best=null,maxA=0;
      for(let i=0;i<contours.size();i++){ const cnt=contours.get(i); const peri=cv.arcLength(cnt,true); const approx=new cv.Mat(); cv.approxPolyDP(cnt,approx,0.02*peri,true); if(approx.rows===4){ const area=cv.contourArea(cnt); if(area>maxA){ maxA=area; best=approx; } } }
      if(best){
        const pts=[]; for(let i=0;i<4;i++) pts.push({x:best.data32S[i*2], y:best.data32S[i*2+1]});
        pts.sort((a,b)=>a.y-b.y); const top=pts.slice(0,2).sort((a,b)=>a.x-b.x); const bottom=pts.slice(2,4).sort((a,b)=>a.x-b.x);
        const ordered=[top[0],top[1],bottom[1],bottom[0]];
        const widthTop=Math.hypot(ordered[0].x-ordered[1].x, ordered[0].y-ordered[1].y);
        const widthBottom=Math.hypot(ordered[3].x-ordered[2].x, ordered[3].y-ordered[2].y);
        const maxW=Math.max(widthTop,widthBottom);
        const heightLeft=Math.hypot(ordered[0].x-ordered[3].x, ordered[0].y-ordered[3].y);
        const heightRight=Math.hypot(ordered[1].x-ordered[2].x, ordered[1].y-ordered[2].y);
        const maxH=Math.max(heightLeft,heightRight);
        const srcCoords = cv.matFromArray(4,1,cv.CV_32FC2,[ordered[0].x,ordered[0].y, ordered[1].x,ordered[1].y, ordered[2].x,ordered[2].y, ordered[3].x,ordered[3].y]);
        const dstCoords = cv.matFromArray(4,1,cv.CV_32FC2,[0,0, maxW-1,0, maxW-1,maxH-1, 0,maxH-1]);
        const M = cv.getPerspectiveTransform(srcCoords,dstCoords); const dst=new cv.Mat(); const dsize=new cv.Size(Math.round(maxW),Math.round(maxH));
        cv.warpPerspective(src,dst,M,dsize,cv.INTER_LINEAR,cv.BORDER_CONSTANT,new cv.Scalar());
        const outCanvas=document.createElement('canvas'); outCanvas.width=dst.cols; outCanvas.height=dst.rows; cv.imshow(outCanvas,dst);
        showCropModal(outCanvas.toDataURL('image/jpeg'));
        src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete(); if(best)best.delete(); srcCoords.delete(); dstCoords.delete(); M.delete(); dst.delete();
        return;
      }
      src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete();
    } catch(err){ console.warn('upload auto-crop failed', err); }
  }
  showCropModal(c.toDataURL('image/jpeg'));
}

/* misc wiring */
document.getElementById('scanNext').addEventListener('click', async ()=> { await finalizeCropAndAdd(); });
document.getElementById('exportBtn').addEventListener('click', async ()=> { await generatePDF({ download:true }); });
document.getElementById('generatePdf').addEventListener('click', async ()=> { await generatePDF({ download:true }); });
document.getElementById('clearAll').addEventListener('click', ()=> { pages=[]; renderPages(); document.getElementById('exportBtn').disabled=true; document.getElementById('generatePdf').disabled=true; document.getElementById('shareBtn').disabled=true; document.getElementById('sharePdf').disabled=true; });
document.querySelectorAll('.filter-btn').forEach(btn=>btn.addEventListener('click', ()=>{ document.querySelectorAll('.filter-btn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); }));
document.getElementById('autoEnhance').addEventListener('click', e=> e.target.classList.toggle('active'));

/* End of script */
</script>
</body>
</html>
