<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scan to PDF — Mobile Scanner</title>

  <!-- Libraries -->
  <!-- OpenCV.js for edge detection / perspective transform -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" ></script>
  <!-- pdf-lib to create high-quality PDF client-side -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <!-- Cropper.js for manual fine cropping -->
  <link  href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

  <style>
    :root{--accent:#0a8b65;--bg:#f6f9fb;--card:#fff;--text:#102a43}
    *{box-sizing:border-box}
    body{font-family:Inter,system-ui,Arial; margin:0; min-height:100vh; background:var(--bg); color:var(--text)}
    header{background:var(--accent); color:white; padding:12px 16px; display:flex;align-items:center;justify-content:space-between}
    header h1{font-size:18px;margin:0}
    .container{max-width:1100px;margin:18px auto;padding:16px}

    .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
    .card{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(16,42,67,0.08)}

    .controls{display:flex;flex-wrap:wrap;gap:8px}
    .controls button,.controls input[type=range],.controls select{padding:8px;border-radius:8px;border:1px solid #dfe7ee;background:white}

    #previewList{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .thumb{width:100px;height:140px;border-radius:6px;overflow:hidden;border:1px solid #e7eef6;display:flex;align-items:center;justify-content:center;position:relative}
    .thumb img{max-width:100%;max-height:100%;display:block}
    .thumb .actions{position:absolute;left:6px;top:6px;display:flex;gap:6px}
    .small{font-size:12px}

    canvas{max-width:100%;border-radius:6px}
    #captureArea{display:flex;flex-direction:column;gap:8px}
    #cameraView{width:100%;height:auto;border-radius:8px;background:#000;object-fit:cover}

    .sliderRow{display:flex;gap:8px;align-items:center}

    footer{padding:12px;text-align:center;color:#6b7c93}

    @media (max-width:900px){.grid{grid-template-columns:1fr}.card{padding:10px}}
  </style>
</head>
<body>
  <header>
    <h1>Scan to PDF — Mobile Scanner</h1>
    <div style="font-size:13px;opacity:.95">Capture • Auto-crop • Filters • Export PDF</div>
  </header>

  <main class="container">
    <div class="grid">
      <!-- Left: Capture & Editor -->
      <section class="card">
        <div id="captureArea">
          <video id="cameraView" autoplay playsinline></video>

          <div class="controls">
            <button id="startCam">Start Camera</button>
            <button id="snapBtn">Take Photo</button>
            <label style="display:inline-flex;align-items:center;gap:6px"><input id="fileInput" type="file" accept="image/*" multiple>Choose Images</label>
            <button id="autoCropBtn">Auto Crop / Edge Detect</button>
            <button id="applyCropBtn">Apply Crop (to editor)</button>
          </div>

          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <label class="small">Rotate</label>
            <button id="rotLeft">⟲</button>
            <button id="rotRight">⟳</button>
            <label class="small">Resize (px)</label>
            <input id="resizeW" type="number" placeholder="width" style="width:90px"> 
            <input id="resizeH" type="number" placeholder="height" style="width:90px">
            <button id="applyResize">Apply</button>
          </div>

          <div style="margin-top:10px">
            <label class="small">Filters</label>
            <div class="controls" style="margin-top:6px">
              <select id="filterSelect">
                <option value="original">Original Color</option>
                <option value="auto">Auto Color (contrast boost)</option>
                <option value="lighttext">Light Text</option>
                <option value="grayscale">Grayscale</option>
                <option value="binarize">Binarize (threshold)</option>
                <option value="invert">Invert</option>
              </select>
              <label class="small">Brightness</label>
              <input id="brightness" type="range" min="-100" max="100" value="0">
              <label class="small">Contrast</label>
              <input id="contrast" type="range" min="-100" max="100" value="0">
              <button id="applyFilter">Apply</button>
            </div>
          </div>

          <div style="margin-top:12px">
            <canvas id="editorCanvas"></canvas>
          </div>

          <div style="margin-top:8px;display:flex;gap:8px">
            <button id="addToDoc">Add to Document</button>
            <button id="downloadAllPDF">Export All as PDF</button>
            <button id="clearAll">Clear</button>
          </div>

        </div>
      </section>

      <!-- Right: Thumbnails & settings -->
      <aside class="card">
        <div>
          <h3 style="margin:0 0 8px 0">Pages</h3>
          <div id="previewList"></div>
        </div>

        <hr style="margin:12px 0">
        <div>
          <h4 style="margin:0 0 8px 0">Quality & PDF Options</h4>
          <div class="small">Image format</div>
          <div style="display:flex;gap:8px;margin-top:6px">
            <label><input type="radio" name="imgFmt" value="jpeg" checked> JPEG</label>
            <label><input type="radio" name="imgFmt" value="png"> PNG</label>
          </div>

          <div style="margin-top:8px" class="small">JPEG Quality (0.1 - 1.0)</div>
          <input id="jpegQuality" type="range" min="0.1" max="1" step="0.05" value="0.9">

          <div style="margin-top:12px" class="small">PDF Page Size</div>
          <select id="pdfSize">
            <option value="auto">Auto (image size)</option>
            <option value="A4">A4</option>
            <option value="Letter">Letter</option>
          </select>

          <div style="margin-top:12px;display:flex;gap:8px">
            <button id="moveUp" class="small">Move Up</button>
            <button id="moveDown" class="small">Move Down</button>
            <button id="delPage" class="small">Delete</button>
          </div>
        </div>
      </aside>
    </div>

  </main>

  <footer>Made with ❤️ — client-side only. Images never leave your device.</footer>

<script>
// Helpers & state
let stream=null; const video=document.getElementById('cameraView');
const editorCanvas=document.getElementById('editorCanvas'); const eCtx=editorCanvas.getContext('2d');
let currentImage=null; // HTMLImageElement for editor
let cropper=null; // Cropper.js instance
let pages=[]; // {blob, dataUrl, width, height}
let opencvReady=false;

// Wait for OpenCV to be ready
function onOpenCvReady(){
  opencvReady=true; console.log('OpenCV ready');
}
if(window.cv && cv['onRuntimeInitialized']){ cv['onRuntimeInitialized']=onOpenCvReady } 

// Camera
document.getElementById('startCam').addEventListener('click', async ()=>{
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  try{
    stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    video.srcObject=stream; video.play();
  }catch(e){alert('Camera not available: '+e.message)}
});

// Snap photo
document.getElementById('snapBtn').addEventListener('click',()=>{
  if(!video.srcObject) return alert('Start the camera first');
  editorCanvas.width=video.videoWidth; editorCanvas.height=video.videoHeight;
  eCtx.drawImage(video,0,0,editorCanvas.width,editorCanvas.height);
  loadEditorFromCanvas();
});

// File input
const fileInput=document.getElementById('fileInput');
fileInput.addEventListener('change',async(e)=>{
  const files=Array.from(e.target.files);
  for(const f of files){
    const url=URL.createObjectURL(f);
    await loadImageToEditor(url);
  }
});

// Utility: load image URL into editor canvas and init cropper
async function loadImageToEditor(url){
  return new Promise((res)=>{
    const img=new Image(); img.onload=()=>{
      editorCanvas.width=img.naturalWidth; editorCanvas.height=img.naturalHeight;
      eCtx.drawImage(img,0,0); currentImage=img; initCropper(); res();
    }; img.crossOrigin='anonymous'; img.src=url;
  });
}
function loadEditorFromCanvas(){
  const url=editorCanvas.toDataURL('image/png'); loadImageToEditor(url);
}

function initCropper(){
  // destroy existing cropper
  if(cropper){ cropper.destroy(); cropper=null; }
  // attach a temporary img element
  const tmp=document.createElement('img'); tmp.style.maxWidth='100%'; tmp.src=editorCanvas.toDataURL();
  // replace canvas with image in DOM for cropper convenience
  editorCanvas.style.display='none';
  tmp.id='tmpEditorImg'; tmp.onload=()=>{
    editorCanvas.parentNode.insertBefore(tmp, editorCanvas);
    cropper=new Cropper(tmp, {viewMode:1, autoCropArea:1, responsive:true, background:false});
  }
}

// Apply crop from cropper back to canvas
document.getElementById('applyCropBtn').addEventListener('click',()=>{
  if(!cropper) return alert('No image loaded');
  const c= cropper.getCroppedCanvas();
  if(!c) return;
  editorCanvas.width=c.width; editorCanvas.height=c.height; eCtx.clearRect(0,0,c.width,c.height); eCtx.drawImage(c,0,0);
  // cleanup
  document.getElementById('tmpEditorImg')?.remove(); cropper.destroy(); cropper=null; editorCanvas.style.display='block';
  currentImage=null; // editor now driven by canvas
});

// Auto crop / edge detect using OpenCV
document.getElementById('autoCropBtn').addEventListener('click', async ()=>{
  if(!opencvReady) return alert('OpenCV not loaded yet');
  // grab image from canvas or video
  let srcCanvas=document.createElement('canvas');
  if(document.getElementById('tmpEditorImg')){
    const img=document.getElementById('tmpEditorImg'); srcCanvas.width=img.naturalWidth; srcCanvas.height=img.naturalHeight; srcCanvas.getContext('2d').drawImage(img,0,0);
  }else{
    if(editorCanvas.width===0) return alert('No image to process'); srcCanvas.width=editorCanvas.width; srcCanvas.height=editorCanvas.height; srcCanvas.getContext('2d').drawImage(editorCanvas,0,0);
  }
  const src = cv.imread(srcCanvas);
  const orig = src.clone();
  try{
    // convert to gray and blur
    let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
    cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
    // Canny
    let edged = new cv.Mat(); cv.Canny(gray, edged, 75, 200);

    // find contours
    let contours = new cv.MatVector(); let hierarchy = new cv.Mat();
    cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

    // find largest 4-point contour
    let maxArea=0; let best=null;
    for(let i=0;i<contours.size();i++){
      let cnt=contours.get(i);
      let peri=cv.arcLength(cnt, true);
      let approx=new cv.Mat(); cv.approxPolyDP(cnt, approx, 0.02*peri, true);
      if(approx.rows===4){
        const area=cv.contourArea(cnt);
        if(area>maxArea){ maxArea=area; best=approx; }
      }
    }
    if(!best){ alert('Document edges not found — try manual crop'); return; }
    // reorder points
    const points=[]; for(let i=0;i<4;i++){ points.push({x:best.data32S[i*2], y:best.data32S[i*2+1]}); }
    // sort to tl,tr,br,bl
    points.sort((a,b)=>a.y-b.y); const top=points.slice(0,2).sort((a,b)=>a.x-b.x); const bottom=points.slice(2,4).sort((a,b)=>a.x-b.x);
    const ordered=[top[0], top[1], bottom[1], bottom[0]];
    // compute width/height
    function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);} 
    const widthTop=dist(ordered[0],ordered[1]); const widthBottom=dist(ordered[3],ordered[2]); const maxW=Math.max(widthTop,widthBottom);
    const heightLeft=dist(ordered[0],ordered[3]); const heightRight=dist(ordered[1],ordered[2]); const maxH=Math.max(heightLeft,heightRight);

    // destination
    const dstCoords = cv.matFromArray(4,1,cv.CV_32FC2,[0,0, maxW-1,0, maxW-1,maxH-1, 0,maxH-1]);
    const srcCoords = cv.matFromArray(4,1,cv.CV_32FC2,[ordered[0].x,ordered[0].y, ordered[1].x,ordered[1].y, ordered[2].x,ordered[2].y, ordered[3].x,ordered[3].y]);
    let M = cv.getPerspectiveTransform(srcCoords, dstCoords);
    let dst = new cv.Mat(); let dsize = new cv.Size(maxW, maxH);
    cv.warpPerspective(orig, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

    // show result in canvas
    cv.imshow(editorCanvas, dst);
    // cleanup
    src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete(); best.delete(); orig.delete(); dst.delete(); srcCoords.delete(); dstCoords.delete(); M.delete();
    loadEditorFromCanvas();
  }catch(err){ console.error(err); alert('Auto-crop failed: '+err.message); }
});

// Filters and adjustments
function applyFilterToCanvas(){
  const data=eCtx.getImageData(0,0,editorCanvas.width, editorCanvas.height);
  const d=data.data; const brightness=parseInt(document.getElementById('brightness').value); const contrast=parseInt(document.getElementById('contrast').value);
  const filter=document.getElementById('filterSelect').value;
  // precompute contrast factor
  const cFactor=(259*(contrast+255))/(255*(259-contrast));
  for(let i=0;i<d.length;i+=4){
    let r=d[i], g=d[i+1], b=d[i+2];
    // filters
    if(filter==='grayscale'){ const v=0.299*r+0.587*g+0.114*b; r=g=b=v; }
    else if(filter==='invert'){ r=255-r; g=255-g; b=255-b; }
    else if(filter==='binarize'){ const v=0.299*r+0.587*g+0.114*b; const t= (128+contrast/2); const val = v>t?255:0; r=g=b=val; }
    else if(filter==='lighttext'){ // enhance text: increase contrast + sharpen
      // convert to gray
      let v=0.299*r+0.587*g+0.114*b; r=g=b=v; 
      // boost
      r = Math.min(255, r*1.25 + 10);
    }
    else if(filter==='auto'){
      // mild auto color: boost contrast and saturation (simple approach)
      // convert to hsl-like manipulation -> simple contrast
      r = cFactor*(r-128)+128; g = cFactor*(g-128)+128; b = cFactor*(b-128)+128;
    }
    // brightness & contrast
    r = cFactor*(r-128)+128 + brightness; g = cFactor*(g-128)+128 + brightness; b = cFactor*(b-128)+128 + brightness;
    d[i]=Math.max(0,Math.min(255,Math.round(r)));
    d[i+1]=Math.max(0,Math.min(255,Math.round(g)));
    d[i+2]=Math.max(0,Math.min(255,Math.round(b)));
  }
  eCtx.putImageData(data,0,0);
}

document.getElementById('applyFilter').addEventListener('click',()=>{
  if(editorCanvas.width===0) return alert('No image'); applyFilterToCanvas(); loadEditorFromCanvas();
});

// Rotate
document.getElementById('rotLeft').addEventListener('click',()=>rotateEditor(-90));
document.getElementById('rotRight').addEventListener('click',()=>rotateEditor(90));
function rotateEditor(deg){
  if(editorCanvas.width===0) return; const off=document.createElement('canvas'); const oCtx=off.getContext('2d');
  if(deg%180!==0){ off.width=editorCanvas.height; off.height=editorCanvas.width; oCtx.translate(off.width/2, off.height/2); oCtx.rotate(deg*Math.PI/180); oCtx.drawImage(editorCanvas, -editorCanvas.width/2, -editorCanvas.height/2); }
  else { off.width=editorCanvas.width; off.height=editorCanvas.height; oCtx.translate(off.width/2, off.height/2); oCtx.rotate(deg*Math.PI/180); oCtx.drawImage(editorCanvas, -editorCanvas.width/2, -editorCanvas.height/2); }
  editorCanvas.width=off.width; editorCanvas.height=off.height; eCtx.clearRect(0,0,off.width,off.height); eCtx.drawImage(off,0,0);
  loadEditorFromCanvas();
}

// Resize
document.getElementById('applyResize').addEventListener('click',()=>{
  const w=parseInt(document.getElementById('resizeW').value); const h=parseInt(document.getElementById('resizeH').value);
  if(!w||!h) return alert('Enter width and height'); const off=document.createElement('canvas'); off.width=w; off.height=h; off.getContext('2d').drawImage(editorCanvas,0,0,w,h);
  editorCanvas.width=w; editorCanvas.height=h; eCtx.drawImage(off,0,0); loadEditorFromCanvas();
});

// Add to document (store the current editor canvas as a page)
document.getElementById('addToDoc').addEventListener('click', async ()=>{
  if(editorCanvas.width===0) return alert('No image to add');
  const fmt = document.querySelector('input[name="imgFmt"]:checked').value;
  const q = parseFloat(document.getElementById('jpegQuality').value);
  const blob = await new Promise(res=>editorCanvas.toBlob(res, fmt==='jpeg'?'image/jpeg':'image/png', q));
  const url = URL.createObjectURL(blob);
  pages.push({blob, url, width:editorCanvas.width, height:editorCanvas.height});
  renderThumbnails();
});

function renderThumbnails(){
  const list=document.getElementById('previewList'); list.innerHTML='';
  pages.forEach((p,i)=>{
    const div=document.createElement('div'); div.className='thumb'; div.dataset.index=i;
    const img=document.createElement('img'); img.src=p.url; img.alt='page '+(i+1);
    const actions=document.createElement('div'); actions.className='actions';
    const sel=document.createElement('button'); sel.textContent='Edit'; sel.title='Edit this page'; sel.addEventListener('click',()=>editPage(i));
    const use=document.createElement('button'); use.textContent='Use'; use.title='Replace editor with this page'; use.addEventListener('click',()=>usePage(i));
    actions.appendChild(sel); actions.appendChild(use);
    const del=document.createElement('button'); del.textContent='✕'; del.style.position='absolute'; del.style.right='4px'; del.style.top='4px'; del.addEventListener('click',()=>{ pages.splice(i,1); renderThumbnails(); });
    div.appendChild(actions); div.appendChild(img); div.appendChild(del); list.appendChild(div);
  });
}

function editPage(i){
  const p=pages[i]; loadImageToEditor(p.url);
}
function usePage(i){ const p=pages[i]; // load into editor canvas for adjustments
  loadImageToEditor(p.url);
}

// Delete, move up/down
document.getElementById('moveUp').addEventListener('click',()=>{ const idx=getSelectedIndex(); if(idx>0){ const temp=pages[idx-1]; pages[idx-1]=pages[idx]; pages[idx]=temp; renderThumbnails(); } });
document.getElementById('moveDown').addEventListener('click',()=>{ const idx=getSelectedIndex(); if(idx<pages.length-1){ const temp=pages[idx+1]; pages[idx+1]=pages[idx]; pages[idx]=temp; renderThumbnails(); } });
document.getElementById('delPage').addEventListener('click',()=>{ const idx=getSelectedIndex(); if(idx>-1){ pages.splice(idx,1); renderThumbnails(); } });

function getSelectedIndex(){ // simple: last clicked thumb
  const sel = document.querySelector('.thumb.selected'); if(!sel) return pages.length-1; return parseInt(sel.dataset.index);
}

// click behavior to select thumbs
document.getElementById('previewList').addEventListener('click',(e)=>{
  const thumb=e.target.closest('.thumb'); if(!thumb) return; document.querySelectorAll('.thumb').forEach(t=>t.classList.remove('selected')); thumb.classList.add('selected');
});

// Export to PDF
document.getElementById('downloadAllPDF').addEventListener('click', async ()=>{
  if(pages.length===0) return alert('Add at least one page');
  const pdfSize = document.getElementById('pdfSize').value;
  const pdfDoc = await PDFLib.PDFDocument.create();
  for(const p of pages){
    // convert blob to arrayBuffer
    const arrayBuffer = await p.blob.arrayBuffer();
    // embed image
    let img;
    if(p.blob.type==='image/png'){ img = await pdfDoc.embedPng(arrayBuffer); }
    else { img = await pdfDoc.embedJpg(arrayBuffer); }
    // page size
    let pageWidth = img.width; let pageHeight = img.height;
    if(pdfSize==='A4'){ // A4 in points (72 DPI) -> 595 x 842
      pageWidth=595; pageHeight=842;
      // fit image into page preserving aspect
      const ratio=Math.min(pageWidth/img.width, pageHeight/img.height);
      const drawW=img.width*ratio; const drawH=img.height*ratio;
      const page = pdfDoc.addPage([pageWidth,pageHeight]);
      page.drawImage(img,{x:(pageWidth-drawW)/2,y:(pageHeight-drawH)/2,width:drawW,height:drawH});
    } else if(pdfSize==='Letter'){
      pageWidth=612; pageHeight=792; const ratio=Math.min(pageWidth/img.width, pageHeight/img.height);
      const drawW=img.width*ratio; const drawH=img.height*ratio; const page=pdfDoc.addPage([pageWidth,pageHeight]); page.drawImage(img,{x:(pageWidth-drawW)/2,y:(pageHeight-drawH)/2,width:drawW,height:drawH});
    } else {
      // auto: use image pixel dims in PDF points (assume 72ppi). To get better quality, we can scale to 300 DPI by multiplying points
      // choose to embed at image pixel size but constrained to max 2000 points to avoid enormous PDFs
      const maxDim=2000; let scale=1; if(img.width>maxDim || img.height>maxDim){ scale = Math.min(maxDim/img.width, maxDim/img.height);}      
      const page = pdfDoc.addPage([Math.round(img.width*scale), Math.round(img.height*scale)]);
      page.drawImage(img,{x:0,y:0,width:Math.round(img.width*scale),height:Math.round(img.height*scale)});
    }
  }
  const pdfBytes = await pdfDoc.save();
  const blob = new Blob([pdfBytes],{type:'application/pdf'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='scanned-'+new Date().toISOString().slice(0,10)+'.pdf'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),2000);
});

// Clear all
document.getElementById('clearAll').addEventListener('click',()=>{ pages.forEach(p=>URL.revokeObjectURL(p.url)); pages=[]; renderThumbnails(); editorCanvas.width=0; editorCanvas.height=0; document.getElementById('tmpEditorImg')?.remove(); if(cropper){cropper.destroy();cropper=null;} });

// Accessibility / fallback: load sample image when page loads (optional)
// window.addEventListener('load', ()=>{/* preload or nothing */});

</script>
</body>
</html>
