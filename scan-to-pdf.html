<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Scan to PDF – PDF Chamber</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/camanjs@4.1.2/dist/caman.full.min.js"></script>
<script async src="https://docs.opencv.org/4.9.0/opencv.js" onload="onOpenCvReady()"></script>
<style>
:root {
  --focus:#00AEEF;
  --transition:all 0.3s ease;
  --bg-gradient:linear-gradient(135deg,#E3F2FD 0%,#BBDEFB 50%,#90CAF9 100%);
  --header-bg:#0a8b65;
  --card-bg:#ffffff;
  --text-primary:#002B5B;
  --text-secondary:#455A64;
  --btn-green:#0a8b65;
  --btn-hover:#087555;
  --footer-bg:#0a8b65;
  --footer-text:#ECEFF1;
  --border-upload:#0a8b65;
  --edge-color:#4CAF50;
  --countdown-bg:rgba(76,175,80,0.9);
}
[data-theme="dark"] {
  --bg-gradient:linear-gradient(135deg,#0D1B2A 0%,#1B263B 50%,#415A77 100%);
  --header-bg:#0a8b65;
  --card-bg:#1B263B;
  --text-primary:#E0E1DD;
  --text-secondary:#AAB4BE;
  --btn-green:#0a8b65;
  --btn-hover:#0b7050;
  --footer-bg:#0a8b65;
  --footer-text:#E0E1DD;
  --border-upload:#0a8b65;
  --edge-color:#66BB6A;
  --countdown-bg:rgba(102,187,106,0.9);
}
*,*::before,*::after {box-sizing:border-box;margin:0;padding:0;}
body {
  font-family:'Inter',sans-serif;
  background:var(--bg-gradient);
  color:var(--text-primary);
  min-height:100vh;
  display:flex;
  flex-direction:column;
}
header {
  background:var(--header-bg);
  color:#fff;
  padding:1rem 5%;
  display:flex;
  justify-content:space-between;
  align-items:center;
}
.logo {
  display:flex;
  align-items:center;
  gap:.75rem;
  font-weight:700;
  font-size:1.8rem;
  color:#fff;
  text-decoration:none;
}
.logo svg {width:40px;height:40px;fill:#fff;}
.theme-toggle {
  width:56px;height:30px;
  background:rgba(255,255,255,.15);
  border:2px solid #ffffff;
  border-radius:50px;
  position:relative;
  cursor:pointer;
}
.theme-toggle::before {
  content:'';position:absolute;top:3px;left:4px;
  width:20px;height:20px;background:#ffffff;
  border-radius:50%;transition:transform 0.3s;
}
[data-theme="dark"] .theme-toggle::before {
  transform:translateX(24px);background:#1B263B;
}
main {
  flex:1;max-width:1200px;margin:2rem auto;padding:0 5%;text-align:center;
}
.sub-headline {
  color:var(--header-bg);font-size:1rem;margin-top:-0.5rem;margin-bottom:1.5rem;line-height:1.4;
}
.sub-headline p {margin:0.2rem 0;}
.upload-area {
  border:3px dashed var(--border-upload);
  border-radius:16px;padding:2rem 1rem;
  background:rgba(255,255,255,0.8);cursor:pointer;margin-bottom:1.5rem;
  position:relative;
}
.upload-area p {color:var(--text-primary);margin-bottom:.5rem;font-size:1.1rem;}
.upload-btn, .camera-btn {
  background:var(--btn-green);color:#fff;border:none;
  padding:.75rem 1.5rem;border-radius:50px;font-weight:600;
  cursor:pointer;transition:var(--transition);margin:0 .25rem;
}
.upload-btn:hover, .camera-btn:hover {background:var(--btn-hover);transform:scale(1.05);}
.camera-btn svg {width:18px;height:18px;vertical-align:middle;margin-right:6px;fill:#fff;}
.preview-container {
  display:flex;flex-wrap:wrap;gap:1rem;justify-content:center;
  margin-top:1.5rem;max-height:500px;overflow-y:auto;padding:1rem;
  border:1px solid var(--border-upload);border-radius:12px;background:var(--card-bg);
}
.preview-item {
  background:var(--card-bg);border:1px solid var(--border-upload);
  border-radius:8px;padding:.5rem;box-shadow:0 2px 6px rgba(0,0,0,.1);
  width:180px;text-align:center;cursor:move;position:relative;
}
.preview-item img {
  width:100%;height:140px;object-fit:contain;background:#f9f9f9;
  border-radius:4px;margin-bottom:.3rem;
}
.preview-item label {
  font-size:.8rem;display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
}
.preview-item .remove {
  position:absolute;top:4px;right:4px;background:#f44336;color:#fff;
  border:none;border-radius:50%;width:20px;height:20px;font-size:12px;
  cursor:pointer;opacity:0.8;
}
.preview-item .remove:hover {opacity:1;}
.counter-box {
  background:var(--card-bg);padding:1rem;border-radius:12px;
  box-shadow:0 2px 6px rgba(0,0,0,.1);max-width:500px;margin:1rem auto;
  color:var(--text-secondary);font-size:0.95rem;
}
.btn {
  background:var(--btn-green);color:#fff;border:none;
  padding:.8rem 2rem;border-radius:8px;font-weight:600;
  cursor:pointer;margin:.5rem;transition:var(--transition);
}
.btn:hover {background:var(--btn-hover);transform:scale(1.05);}
.btn:disabled {opacity:.5;cursor:not-allowed;}
.toggle-container {
  display:flex;flex-direction:column;gap:.75rem;align-items:center;
  margin:1rem auto;max-width:500px;
}
.enhance-toggle, .grayscale-toggle, .crop-toggle {
  display:flex;align-items:center;gap:.5rem;font-size:0.9rem;
}
.enhance-toggle input, .grayscale-toggle input, .crop-toggle input {
  accent-color:var(--btn-green);
}
footer {
  background:var(--footer-bg);color:var(--footer-text);
  text-align:center;padding:1.5rem 5%;font-size:.9rem;margin-top:auto;
}
.back-home {display:flex;justify-content:center;margin-top:1.5rem;}
.spinner {margin:2rem 0;font-style:italic;color:#777;}

/* Camera Modal */
.camera-modal {
  display:none;position:fixed;top:0;left:0;width:100%;height:100%;
  background:rgba(0,0,0,0.9);z-index:1000;align-items:center;justify-content:center;
  flex-direction:column;padding:1rem;
}
.camera-container {
  position:relative;width:100%;max-width:500px;height:70vh;background:#000;
  border-radius:12px;overflow:hidden;
}
#cameraVideo {width:100%;height:100%;object-fit:cover;}
.edge-overlay {
  position:absolute;top:0;left:0;width:100%;height:100%;
  pointer-events:none;z-index:10;
}
.edge-overlay canvas {width:100%;height:100%;opacity:0.7;}
.camera-controls {
  display:flex;gap:.75rem;margin-top:1rem;justify-content:center;flex-wrap:wrap;
}
.camera-controls button {
  background:var(--btn-green);color:#fff;border:none;
  padding:.75rem 1.25rem;border-radius:50px;font-weight:600;
  cursor:pointer;transition:var(--transition);display:flex;align-items:center;gap:.5rem;
  font-size:0.9rem;
}
.camera-controls button:hover {background:var(--btn-hover);}
.camera-controls button svg {width:18px;height:18px;fill:#fff;}
#closeCamera {background:#f44336;}
#closeCamera:hover {background:#d32f2f;}
#flashToggle {
  background:#ffa726;color:#fff;
}
#flashToggle.active {background:#ff8f00;}
#flashToggle.auto {background:#4caf50;}
#flashToggle.auto.active {background:#388e3c;}

/* Auto-Capture */
.countdown-overlay {
  position:absolute;top:0;left:0;width:100%;height:100%;
  background:var(--countdown-bg);color:#fff;
  display:flex;align-items:center;justify-content:center;
  font-size:3rem;font-weight:700;z-index:20;
  opacity:0;pointer-events:none;transition:opacity 0.3s;
}
.countdown-overlay.show {opacity:1;pointer-events:auto;}
</style>
</head>
<body>
<header>
  <a href="index.html" class="logo">
    <svg viewBox="0 0 24 24"><path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"/></svg>
    PDF Chamber
  </a>
  <div class="theme-toggle" id="themeToggle"></div>
</header>
<main>
  <h1>Scan to PDF</h1>
  <div class="sub-headline">
    <p>Your ultimate online PDF tools hub.</p>
    <p>Auto-capture when aligned, edge detection, flash — perfect scans hands-free.</p>
  </div>

  <div class="upload-area" id="uploadArea">
    <p>Drag & drop images here or click to upload</p>
    <div style="margin-top:.5rem;">
      <button class="upload-btn">Choose Images</button>
      <button class="camera-btn" id="openCamera">
        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14l-3-3 1.41-1.41L10 13.17l4.59-4.58L16 10l-6 6z"/></svg>
        Take Photo
      </button>
    </div>
    <input type="file" id="fileInput" accept="image/*" hidden multiple>
  </div>

  <div class="counter-box" id="counterBox">No images uploaded</div>

  <div class="toggle-container" id="toggleContainer" hidden>
    <div class="crop-toggle">
      <input type="checkbox" id="autoCrop" checked>
      <label for="autoCrop">Auto-Crop Document</label>
    </div>
    <div class="enhance-toggle">
      <input type="checkbox" id="autoEnhance" checked>
      <label for="autoEnhance">Auto-Enhance</label>
    </div>
    <div class="grayscale-toggle">
      <input type="checkbox" id="grayscale">
      <label for="grayscale">Grayscale Scan Mode</label>
    </div>
  </div>

  <div id="previewContainer" class="preview-container"></div>

  <button class="btn" id="createBtn" disabled>Create PDF</button>
  <button class="btn" id="downloadBtn" disabled>Download PDF</button>

  <div class="back-home">
    <a href="index.html"><button class="btn">Back to Home</button></a>
  </div>
</main>

<!-- Camera Modal -->
<div class="camera-modal" id="cameraModal">
  <div class="camera-container">
    <video id="cameraVideo" autoplay playsinline></video>
    <div class="edge-overlay">
      <canvas id="edgeCanvas"></canvas>
    </div>
    <div class="countdown-overlay" id="countdownOverlay">3</div>
  </div>
  <div class="camera-controls">
    <button id="flashToggle">
      <svg viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg>
      Flash OFF
    </button>
    <button id="capturePhoto">
      <svg viewBox="0 0 24 24"><path d="M12 15c1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3 1.34 3 3 3zm6-11H6c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 14H6V6h12v12z"/></svg>
      Capture
    </button>
    <button id="closeCamera">
      <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
      Close
    </button>
  </div>
</div>

<footer>© 2025 PDF Chamber. All rights reserved.</footer>

<script>
let uploadedImages = [];
let processedImages = [];
let pdfBlobUrl = null;
const A4_WIDTH = 595.28;
const A4_HEIGHT = 841.89;
const MARGIN = 40;

// DOM
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('fileInput');
const previewContainer = document.getElementById('previewContainer');
const counterBox = document.getElementById('counterBox');
const createBtn = document.getElementById('createBtn');
const downloadBtn = document.getElementById('downloadBtn');
const openCamera = document.getElementById('openCamera');
const cameraModal = document.getElementById('cameraModal');
const cameraVideo = document.getElementById('cameraVideo');
const edgeCanvas = document.getElementById('edgeCanvas');
const countdownOverlay = document.getElementById('countdownOverlay');
const capturePhoto = document.getElementById('capturePhoto');
const closeCamera = document.getElementById('closeCamera');
const flashToggle = document.getElementById('flashToggle');
const toggleContainer = document.getElementById('toggleContainer');
const autoCrop = document.getElementById('autoCrop');
const autoEnhance = document.getElementById('autoEnhance');
const grayscale = document.getElementById('grayscale');

// Camera & CV
let stream = null;
let cvReady = false;
let track = null;
let flashMode = 'off';
let autoFlashInterval = null;
let isProcessingFrame = false;
let stableFrames = 0;
let autoCaptureTimer = null;
let countdownInterval = null;

// Reusable OpenCV Mats
let src = null, gray = null, blurred = null, edges = null;
let contours = null, hierarchy = null;

// Downscaled processing
const PROCESS_WIDTH = 320;
const PROCESS_HEIGHT = 240;
let processCanvas = null;
let processCtx = null;

// Auto-capture thresholds
const STABLE_THRESHOLD = 6; // ~3 sec at 2 FPS
const MIN_AREA = 8000;
const MAX_AREA = 50000;

// OpenCV Ready
function onOpenCvReady() {
  cvReady = true;
  console.log('OpenCV.js ready');

  src = new cv.Mat();
  gray = new cv.Mat();
  blurred = new cv.Mat();
  edges = new cv.Mat();
  contours = new cv.MatVector();
  hierarchy = new cv.Mat();

  processCanvas = document.createElement('canvas');
  processCanvas.width = PROCESS_WIDTH;
  processCanvas.height = PROCESS_HEIGHT;
  processCtx = processCanvas.getContext('2d');
}

// Draw edges
function drawEdges(approx) {
  const ctx = edgeCanvas.getContext('2d');
  ctx.clearRect(0, 0, edgeCanvas.width, edgeCanvas.height);
  if (!approx) return;

  const scaleX = edgeCanvas.width / PROCESS_WIDTH;
  const scaleY = edgeCanvas.height / PROCESS_HEIGHT;

  const points = [];
  for (let i = 0; i < approx.data32S.length; i += 2) {
    points.push({ x: approx.data32S[i] * scaleX, y: approx.data32S[i + 1] * scaleY });
  }

  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.closePath();

  const area = Math.abs(cv.contourArea(approx));
  const isGood = area > MIN_AREA && area < MAX_AREA;

  ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--edge-color');
  ctx.lineWidth = isGood ? 5 : 2;
  ctx.setLineDash(isGood ? [] : [8, 8]);
  ctx.stroke();

  return { area, isGood };
}

// Edge detection + auto-capture
function detectEdges() {
  if (!cvReady || !cameraVideo.videoWidth || isProcessingFrame) return;
  isProcessingFrame = true;

  processCtx.drawImage(cameraVideo, 0, 0, PROCESS_WIDTH, PROCESS_HEIGHT);
  cv.imread(processCanvas, src);

  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
  cv.Canny(blurred, edges, 75, 150);

  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let bestApprox = null;
  let largestArea = 0;

  for (let i = 0; i < contours.size(); ++i) {
    const cnt = contours.get(i);
    const area = cv.contourArea(cnt);
    if (area > largestArea && area > 3000) {
      const peri = cv.arcLength(cnt, true);
      const approx = new cv.Mat();
      cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
      if (approx.rows === 4) {
        largestArea = area;
        bestApprox = approx;
      } else {
        approx.delete();
      }
    }
  }

  const result = drawEdges(bestApprox);
  if (bestApprox) bestApprox.delete();

  // Auto-capture logic
  if (result && result.isGood) {
    stableFrames++;
    if (stableFrames >= STABLE_THRESHOLD && !autoCaptureTimer) {
      startCountdown();
    }
  } else {
    stableFrames = 0;
    cancelCountdown();
  }

  isProcessingFrame = false;
}

// Countdown
function startCountdown() {
  if (autoCaptureTimer) return;
  let seconds = 3;
  countdownOverlay.textContent = seconds;
  countdownOverlay.classList.add('show');

  countdownInterval = setInterval(() => {
    seconds--;
    countdownOverlay.textContent = seconds;
    if (seconds <= 0) {
      clearInterval(countdownInterval);
      capturePhoto.click();
    }
  }, 1000);

  autoCaptureTimer = setTimeout(() => {
    clearInterval(countdownInterval);
    countdownOverlay.classList.remove('show');
    autoCaptureTimer = null;
  }, 3500);
}

function cancelCountdown() {
  if (autoCaptureTimer) {
    clearTimeout(autoCaptureTimer);
    clearInterval(countdownInterval);
    countdownOverlay.classList.remove('show');
    autoCaptureTimer = null;
  }
}

// RAF loop
let lastFrameTime = 0;
function edgeLoop(timestamp) {
  if (cameraModal.style.display !== 'flex') return;
  if (timestamp - lastFrameTime > 500) {
    detectEdges();
    lastFrameTime = timestamp;
  }
  requestAnimationFrame(edgeLoop);
}

function startEdgeDetection() {
  edgeCanvas.width = cameraVideo.clientWidth;
  edgeCanvas.height = cameraVideo.clientHeight;
  lastFrameTime = 0;
  stableFrames = 0;
  requestAnimationFrame(edgeLoop);
}

// Flash
async function setFlash(on) {
  if (!track?.getCapabilities().torch) return;
  try { await track.applyConstraints({ advanced: [{ torch: on }] }); } catch (e) {}
}

function getLuminosity() {
  processCtx.drawImage(cameraVideo, 0, 0, 80, 60);
  const data = processCtx.getImageData(0, 0, 80, 60).data;
  let sum = 0;
  for (let i = 0; i < data.length; i += 4) sum += 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
  return sum / (data.length / 4);
}

function startAutoFlash() {
  if (autoFlashInterval) clearInterval(autoFlashInterval);
  autoFlashInterval = setInterval(() => {
    if (flashMode !== 'auto') return;
    const shouldFlash = getLuminosity() < 60;
    setFlash(shouldFlash);
    flashToggle.classList.toggle('active', shouldFlash);
  }, 500);
}

function cycleFlashMode() {
  const modes = ['off', 'on', 'auto'];
  flashMode = modes[(modes.indexOf(flashMode) + 1) % 3];
  flashToggle.className = '';
  const isOn = flashMode === 'on' || (flashMode === 'auto' && getLuminosity() < 60);
  flashToggle.classList.toggle('active', isOn);
  if (flashMode === 'auto') flashToggle.classList.add('auto');
  flashToggle.innerHTML = `<svg viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg> Flash ${flashMode.toUpperCase()}`;
  if (flashMode === 'on') setFlash(true);
  else if (flashMode === 'off') setFlash(false);
  else startAutoFlash();
}

// Open Camera
openCamera.addEventListener('click', async () => {
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });

    track = stream.getVideoTracks()[0];
    cameraVideo.srcObject = stream;
    cameraModal.style.display = 'flex';

    if (track.getCapabilities().torch) {
      flashToggle.style.display = 'flex';
      flashToggle.onclick = cycleFlashMode;
      flashMode = 'off';
      cycleFlashMode();
    } else {
      flashToggle.style.display = 'none';
    }

    cameraVideo.onloadedmetadata = () => startEdgeDetection();

  } catch (err) {
    alert('Camera access denied.');
    console.error(err);
  }
});

// Close Camera
closeCamera.addEventListener('click', () => {
  if (stream) stream.getTracks().forEach(t => t.stop());
  if (autoFlashInterval) clearInterval(autoFlashInterval);
  cancelCountdown();
  cameraModal.style.display = 'none';
  cameraVideo.srcObject = null;
  stream = track = null;
});

// Capture
capturePhoto.addEventListener('click', async () => {
  cancelCountdown();
  const canvas = document.createElement('canvas');
  canvas.width = cameraVideo.videoWidth;
  canvas.height = cameraVideo.videoHeight;
  canvas.getContext('2d').drawImage(cameraVideo, 0, 0);

  canvas.toBlob(async (blob) => {
    const file = new File([blob], `photo-${Date.now()}.jpg`, { type: 'image/jpeg' });
    uploadedImages.push(file);
    processedImages.push(await processImage(file));
    renderPreviews(); updateCounter(); createBtn.disabled = false; toggleControls();
  }, 'image/jpeg', 0.9);

  closeCamera.click();
});

// Process Image (unchanged)
async function processImage(file) {
  let img = file;
  if (autoCrop.checked && cvReady) img = await autoCropImage(img);
  return new Promise(resolve => {
    const url = URL.createObjectURL(img);
    const image = new Image();
    image.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = image.width; canvas.height = image.height;
      Caman(canvas, image, function () {
        if (grayscale.checked) { this.greyscale(); this.contrast(25); this.sharpen(10); }
        else if (autoEnhance.checked) { this.brightness(8); this.contrast(12); this.sharpen(8); this.vibrance(15); }
        this.render(() => {
          canvas.toBlob(blob => {
            resolve(new File([blob], file.name, { type: blob.type }));
            URL.revokeObjectURL(url);
          }, img.type.includes('png') ? 'image/png' : 'image/jpeg', 0.95);
        });
      });
    };
    image.src = url;
  });
}

// Auto-crop (unchanged)
async function autoCropImage(file) {
  if (!cvReady || !autoCrop.checked) return file;
  return new Promise(resolve => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width; canvas.height = img.height;
      const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0);
      const src = cv.imread(canvas);
      const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0); cv.Canny(gray, gray, 50, 150);
      const contours = new cv.MatVector(); const hierarchy = new cv.Mat();
      cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let bestRect = null; let largest = 0;
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i); const area = cv.contourArea(cnt);
        if (area > largest && area > 5000) {
          const peri = cv.arcLength(cnt, true); const approx = new cv.Mat();
          cv.approxPolyDP(cnt, approx, 0.02*peri, true);
          if (approx.rows === 4) { largest = area; bestRect = approx; } else approx.delete();
        }
      }
      if (bestRect) {
        const points = []; for (let j=0;j<4;j++) points.push({x:bestRect.data32S[j*2], y:bestRect.data32S[j*2+1]});
        const ordered = [points[0], points[1], points[3], points[2]].sort((a,b)=>a.x-b.x);
        const width = Math.max(cv.norm(ordered[0], ordered[1]), cv.norm(ordered[2], ordered[3]));
        const height = Math.max(cv.norm(ordered[1], ordered[2]), cv.norm(ordered[3], ordered[0]));
        const dst = cv.matFromArray(4,1,cv.CV_32FC2,[0,0,width-1,0,width-1,height-1,0,height-1].flat());
        const srcTri = cv.matFromArray(4,1,cv.CV_32FC2,ordered.flatMap(p=>[p.x,p.y]));
        const M = cv.getPerspectiveTransform(srcTri, dst);
        const warped = new cv.Mat(); cv.warpPerspective(src, warped, M, new cv.Size(width, height));
        cv.imshow(canvas, warped); warped.delete(); M.delete(); srcTri.delete(); dst.delete();
      }
      canvas.toBlob(b=>resolve(new File([b],file.name,{type:b.type})), file.type.includes('png')?'image/png':'image/jpeg',0.95);
      src.delete(); gray.delete(); contours.delete(); hierarchy.delete();
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });
}

// Upload, render, PDF, theme (unchanged)
uploadArea.addEventListener('click', e => { if (!e.target.closest('.camera-btn')) fileInput.click(); });
['dragover','dragenter'].forEach(ev=>uploadArea.addEventListener(ev,e=>{e.preventDefault();uploadArea.style.borderColor='var(--btn-green)';}));
['dragleave','drop'].forEach(ev=>uploadArea.addEventListener(ev,e=>{e.preventDefault();uploadArea.style.borderColor='var(--border-upload)';}));
uploadArea.addEventListener('drop', e => handleFiles(e.dataTransfer.files));
fileInput.addEventListener('change', e => handleFiles(e.target.files));

async function handleFiles(files) {
  const valid = Array.from(files).filter(f=>f.type.startsWith('image/'));
  if (!valid.length) return alert('Please upload images.');
  for (const f of valid) { uploadedImages.push(f); processedImages.push(await processImage(f)); }
  renderPreviews(); updateCounter(); createBtn.disabled=false; toggleControls();
}

function removeImage(i) { uploadedImages.splice(i,1); processedImages.splice(i,1); renderPreviews(); toggleControls(); }
function renderPreviews() {
  previewContainer.innerHTML = '';
  processedImages.forEach((f,i) => {
    const url = URL.createObjectURL(f);
    const div = document.createElement('div'); div.className='preview-item'; div.dataset.index=i;
    div.innerHTML = `<img src="${url}"><label title="${f.name}">${f.name.slice(0,20)+(f.name.length>20?'...':'')}</label><button class="remove" onclick="removeImage(${i})">X</button>`;
    previewContainer.appendChild(div);
  });
  initSortable();
}
function updateCounter() { counterBox.textContent = `${uploadedImages.length} Image${uploadedImages.length!==1?'s':''} | Drag to Reorder`; }
function initSortable() {
  new Sortable(previewContainer, { animation:150, ghostClass:'sortable-ghost', onEnd:()=>{
    const order = Array.from(previewContainer.querySelectorAll('.preview-item')).map(el=>parseInt(el.dataset.index));
    uploadedImages = order.map(i=>uploadedImages[i]); processedImages = order.map(i=>processedImages[i]); renderPreviews();
  }});
}
function toggleControls() { toggleContainer.hidden = uploadedImages.length === 0; }

autoCrop.addEventListener('change', reprocessAll);
autoEnhance.addEventListener('change', reprocessAll);
grayscale.addEventListener('change', reprocessAll);
async function reprocessAll() {
  if (!uploadedImages.length) return;
  processedImages = []; previewContainer.innerHTML = '<div class="spinner">Processing…</div>';
  for (const f of uploadedImages) processedImages.push(await processImage(f));
  renderPreviews();
}

createBtn.addEventListener('click', async () => {
  if (!processedImages.length) return;
  createBtn.disabled = true; createBtn.textContent = 'Creating…';
  previewContainer.innerHTML = '<div class="spinner">Generating PDF…</div>';
  try {
    const pdf = await PDFLib.PDFDocument.create();
    let page = pdf.addPage([A4_WIDTH, A4_HEIGHT]);
    let y = A4_HEIGHT - MARGIN;
    for (const file of processedImages) {
      const buf = await file.arrayBuffer();
      const img = await (file.type.includes('png') ? pdf.embedPng(buf) : pdf.embedJpg(buf));
      let w = img.width, h = img.height;
      const maxW = A4_WIDTH - 2*MARGIN, maxH = y - MARGIN;
      if (w > maxW) { h = (maxW/w)*h; w = maxW; }
      if (h > maxH) { w = (maxH/h)*w; h = maxH; }
      if (y - h < MARGIN) { page = pdf.addPage([A4_WIDTH,A4_HEIGHT]); y = A4_HEIGHT - MARGIN; }
      page.drawImage(img, { x:(A4_WIDTH-w)/2, y:y-h, width:w, height:h });
      y -= h + 20;
    }
    const bytes = await pdf.save();
    if (pdfBlobUrl) URL.revokeObjectURL(pdfBlobUrl);
    pdfBlobUrl = URL.createObjectURL(new Blob([bytes], {type:'application/pdf'}));
    const mode = [autoCrop.checked&&'cropped', autoEnhance.checked&&'enhanced', grayscale.checked&&'grayscale'].filter(Boolean).join('-')||'original';
    previewContainer.innerHTML = `<div style="color:green;font-weight:600;">PDF Created! (${mode})</div>`;
    downloadBtn.disabled = false;
  } catch(e) { alert('Error'); console.error(e); }
  createBtn.disabled = false; createBtn.textContent = 'Create PDF';
});

downloadBtn.addEventListener('click', () => {
  if (!pdfBlobUrl) return;
  const a = document.createElement('a');
  a.href = pdfBlobUrl;
  const mode = [autoCrop.checked&&'cropped', autoEnhance.checked&&'enhanced', grayscale.checked&&'grayscale'].filter(Boolean).join('-')||'original';
  a.download = `scanned-${mode}-${new Date().toISOString().slice(0,10)}.pdf`;
  a.click();
  setTimeout(() => URL.revokeObjectURL(pdfBlobUrl), 1000);
});

const themeToggle = document.getElementById('themeToggle');
const html = document.documentElement;
if (localStorage.theme === 'dark' || (!localStorage.theme && window.matchMedia('(prefers-color-scheme:dark)').matches)) html.dataset.theme = 'dark';
themeToggle.addEventListener('click', () => {
  html.dataset.theme = html.dataset.theme === 'dark' ? 'light' : 'dark';
  localStorage.theme = html.dataset.theme;
});
</script>
</body>
</html>
