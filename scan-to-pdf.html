<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scan to PDF — PDF Chamber</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<!-- CDNs -->
<script src="https://docs.opencv.org/4.7.0/opencv.js"></script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script src="https://unpkg.com/sortablejs@1.15.0/Sortable.min.js"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
<script src="https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js"></script>

<style>
:root {
  --focus:#00AEEF;
  --transition:all 0.3s ease;
  --bg-gradient:linear-gradient(135deg,#E3F2FD 0%,#BBDEFB 50%,#90CAF9 100%);
  --header-bg:#0a8b65;
  --card-bg:#ffffff;
  --text-primary:#002B5B;
  --text-secondary:#455A64;
  --btn-green:#0a8b65;
  --btn-hover:#087555;
  --footer-bg:#0a8b65;
  --footer-text:#ECEFF1;
  --border-upload:#0a8b65;
}
[data-theme="dark"] {
  --bg-gradient:linear-gradient(135deg,#0D1B2A 0%,#1B263B 50%,#415A77 100%);
  --header-bg:#0a8b65;
  --card-bg:#1B263B;
  --text-primary:#E0E1DD;
  --text-secondary:#AAB4BE;
  --btn-green:#0a8b65;
  --btn-hover:#0b7050;
  --footer-bg:#0a8b65;
  --footer-text:#E0E1DD;
  --border-upload:#0a8b65;
}

*,*::before,*::after { box-sizing: border-box; margin:0; padding:0; }
body {
  font-family:'Inter',sans-serif;
  background:var(--bg-gradient);
  color:var(--text-primary);
  min-height:100vh;
  display:flex;
  flex-direction:column;
}

/* Header */
header {
  background:var(--header-bg);
  color:#fff;
  padding:1rem 5%;
  display:flex;
  justify-content:space-between;
  align-items:center;
}
.logo {
  display:flex;
  align-items:center;
  gap:.75rem;
  font-weight:700;
  font-size:1.8rem;
  color:#fff;
  text-decoration:none;
}
.logo svg {width:40px;height:40px;fill:#fff;}
.theme-toggle {
  width:56px;
  height:30px;
  background:rgba(255,255,255,.15);
  border:2px solid #ffffff;
  border-radius:50px;
  position:relative;
  cursor:pointer;
}
.theme-toggle::before {
  content:'';
  position:absolute;
  top:3px;
  left:4px;
  width:20px;
  height:20px;
  background:#ffffff;
  border-radius:50%;
  transition:transform 0.3s;
}
[data-theme="dark"] .theme-toggle::before {
  transform:translateX(24px);
  background:#1B263B;
}

/* Main */
main {
  flex:1;
  max-width:1200px;
  margin:2rem auto;
  padding:0 5%;
}
.grid {
  display:grid;
  grid-template-columns: 1fr 360px;
  gap:1rem;
  align-items:start;
}
.card {
  background:var(--card-bg);
  border-radius:12px;
  padding:1rem;
  box-shadow:0 6px 18px rgba(2,40,60,.08);
}

/* Camera area */
.camera-wrap { position:relative; border-radius:10px; overflow:hidden; background:#000; height:420px; display:flex; align-items:center; justify-content:center; }
video#cameraView { width:100%; height:100%; object-fit:cover; display:block; }
canvas#overlay { position:absolute; left:0; top:0; pointer-events:none; }

/* Controls */
.controls { display:flex; flex-wrap:wrap; gap:.5rem; margin-top:.75rem; justify-content:space-between; }
.btn { background:var(--btn-green); color:#fff; border:none; padding:.6rem 1rem; border-radius:8px; font-weight:600; cursor:pointer; transition:var(--transition); }
.btn:hover { background:var(--btn-hover); transform:scale(1.03); }
.toggle { background: rgba(255,255,255,0.9); padding:.45rem .75rem; border-radius:8px; border:2px solid #fff; cursor:pointer; font-weight:600; }

.small { font-size:.95rem; color:var(--text-secondary); margin-top:.5rem; }

/* Preview list */
.preview-list { display:flex; flex-direction:column; gap:.5rem; max-height:62vh; overflow:auto; margin-top:.5rem; }
.thumb { display:flex; align-items:center; gap:.5rem; padding:.5rem; border-radius:8px; background:var(--card-bg); border:1px solid rgba(0,0,0,.04); }
.thumb canvas { width:90px; height:auto; border-radius:6px; }

/* Modal (cropper) */
.modal { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.6); z-index:60; }
.modal.show { display:flex; }
.modal .modal-card { background:var(--card-bg); border-radius:10px; width:min(980px,95%); height:min(90vh,90%); padding:12px; display:flex; flex-direction:column; gap:8px; }
.img-wrap { flex:1; overflow:auto; display:flex; align-items:center; justify-content:center; }

/* Onboarding */
.onboard-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; z-index:100; }
.onboard-card { width:min(720px,92%); background:var(--card-bg); border-radius:12px; padding:18px; box-shadow:0 8px 30px rgba(0,0,0,0.4); color:var(--text-primary); display:flex; flex-direction:column; gap:10px; }
.onboard-steps { display:flex; gap:8px; align-items:center; justify-content:center; margin-top:6px; }
.onboard-step { min-width:12px; height:12px; border-radius:50%; background:#eee; }
.onboard-step.active { background:var(--btn-green); }

.onboard-hero { display:flex; gap:12px; align-items:center; }
.onboard-hero img { width:120px; height:auto; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.08); background:#f7f9fc; }

.onboard-controls { display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }

/* Sliders row */
.row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }

/* Footer */
footer { background:var(--footer-bg); color:var(--footer-text); text-align:center; padding:1.25rem 5%; margin-top:1rem; border-top-left-radius:8px; border-top-right-radius:8px; }

@media (max-width:900px){
  .grid { grid-template-columns: 1fr; }
  .modal .modal-card { width:95%; height:95%; }
  .onboard-card { padding:12px; }
}
</style>
</head>
<body>
<header>
  <a href="index.html" class="logo">
    <svg viewBox="0 0 24 24"><path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"/></svg>
    PDF Chamber
  </a>
  <div class="theme-toggle" id="themeToggle" title="Toggle theme"></div>
</header>

<main>
  <div class="grid">
    <!-- Left: Camera + controls -->
    <section class="card">
      <div class="camera-wrap" id="cameraWrap">
        <video id="cameraView" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="controls" style="margin-top:.8rem;">
        <div style="display:flex;gap:.5rem;flex-wrap:wrap">
          <button class="btn" id="startCam">Open Camera</button>
          <button class="btn" id="modeToggle">Auto-Capture: On</button>
          <button class="btn" id="captureBtn">Tap to Capture</button>
          <label class="toggle" id="uploadLabel">Choose Images<input id="fileInput" type="file" accept="image/*" multiple hidden></label>
        </div>

        <div style="display:flex;gap:.5rem;flex-wrap:wrap">
          <button class="btn" id="scanNext" disabled>Confirm & Scan Next</button>
          <button class="btn" id="generatePdf" disabled>Generate PDF</button>
        </div>
      </div>

      <div class="small">Filters & Enhancements</div>
      <div class="controls" style="justify-content:flex-start;margin-top:.5rem;">
        <button class="btn" id="autoEnhance">Auto-Enhance</button>
        <button class="btn filter-btn active" data-filter="original">Original</button>
        <button class="btn filter-btn" data-filter="auto">Auto Color</button>
        <button class="btn filter-btn" data-filter="light">Light Text</button>
        <button class="btn filter-btn" data-filter="gray">Grayscale</button>
        <button class="btn filter-btn" data-filter="binarize">B&W</button>
      </div>

      <div class="row" style="margin-top:.75rem;">
        <div class="small">Brightness</div>
        <input id="brightness" type="range" min="0" max="200" value="100">
        <div class="small">Contrast</div>
        <input id="contrast" type="range" min="0" max="200" value="100">
      </div>

      <div class="row" style="margin-top:.5rem;align-items:center;">
        <label class="small"><input type="checkbox" id="searchablePdf"> Make searchable (OCR)</label>
        <label class="small"><input type="checkbox" id="deskew"> Auto-deskew</label>
        <label class="small"><input type="checkbox" id="shadowRemove"> Reduce shadows</label>
        <label class="small">Output:
          <select id="pdfSize"><option value="auto">Auto</option><option value="A4">A4</option><option value="Letter">Letter</option></select>
        </label>
        <label class="small">JPEG Quality <input id="jpegQuality" type="range" min="0.5" max="1" step="0.05" value="0.95"></label>
      </div>

      <div class="small" style="margin-top:.75rem;color:var(--text-secondary)">Tip: Use Auto-Capture for hands-free scanning. After capture you can fine-tune crop in the full-screen editor.</div>
    </section>

    <!-- Right: Pages list -->
    <aside class="card">
      <h3 style="margin:0 0 .5rem 0">Scanned Pages</h3>
      <div class="small" style="margin-bottom:.5rem">Drag to reorder. Edit / Delete or Save project locally.</div>
      <div id="pageList" class="preview-list" aria-live="polite"></div>

      <div class="controls" style="margin-top:.5rem;justify-content:flex-start;">
        <button class="btn" id="saveProject">Save Project</button>
        <button class="btn" id="loadProject">Load Project</button>
        <button class="btn" id="exportBtn" disabled>Export PDF</button>
        <button class="btn" id="clearAll">Clear</button>
      </div>
    </aside>
  </div>
</main>

<!-- Cropper modal -->
<div id="cropModal" class="modal" role="dialog" aria-modal="true">
  <div class="modal-card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small">Adjust corners & crop</div>
      <div style="display:flex;gap:.5rem">
        <button class="btn" id="retakeBtn">Retake</button>
        <button class="btn" id="confirmCrop">Confirm</button>
      </div>
    </div>

    <div class="img-wrap">
      <img id="cropImage" style="max-width:100%;display:block;margin:0 auto" alt="Crop preview">
    </div>

    <div style="display:flex;gap:.5rem;justify-content:flex-end">
      <button class="btn" id="scanNextModal">Confirm & Scan Next</button>
      <button class="btn" id="generateModal">Generate PDF</button>
    </div>
  </div>
</div>

<!-- Onboarding (first time only) -->
<div id="onboard" class="onboard-overlay" style="display:none">
  <div class="onboard-card" role="dialog" aria-modal="true" aria-label="Quick tour">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:700;font-size:1.1rem">Welcome to PDF Chamber — Scan to PDF</div>
      <div style="font-size:.9rem;color:var(--text-secondary)"><button id="onboardSkip" class="btn">Skip</button></div>
    </div>

    <div style="display:flex;gap:12px;align-items:center">
      <div class="onboard-hero">
        <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='240' height='160' viewBox='0 0 240 160'><rect width='240' height='160' rx='12' fill='%23F7FBFF'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='%23002B5B' font-family='Inter,Arial' font-size='14'>Scan • Enhance • Export</text></svg>" alt="Scan demo">
      </div>
      <div style="flex:1">
        <ol style="padding-left:1rem">
          <li><strong>Open Camera</strong> — tap <em>Open Camera</em> to use your device camera (choose back camera).</li>
          <li><strong>Auto-capture</strong> will detect document edges automatically; hold steady to capture hands-free.</li>
          <li><strong>Edit & enhance</strong> after capture — crop, rotate, apply filters, adjust brightness/contrast.</li>
          <li><strong>Make searchable</strong> by enabling OCR, then export a high-quality searchable PDF.</li>
        </ol>
        <div class="onboard-steps" id="onboardSteps">
          <div class="onboard-step active"></div>
          <div class="onboard-step"></div>
          <div class="onboard-step"></div>
        </div>
      </div>
    </div>

    <div class="onboard-controls">
      <button id="onboardPrev" class="btn" style="display:none">Back</button>
      <button id="onboardNext" class="btn">Next</button>
      <button id="onboardDone" class="btn" style="display:none">Done</button>
    </div>
  </div>
</div>

<footer>© 2025 PDF Chamber. All rights reserved.</footer>

<script>
/* ------------- Configuration & state ------------- */
const TESS_LANGS = 'eng+spa+fra+deu+ita+por+hin+chi_sim+jpn+kor';
const TESS_OPTIONS = { logger: m => console.log('Tesseract:', m) };

let stream = null;
let cvReady = false;
let processing = false;
let stabilityCounter = 0;
let lastContour = null;
let cropper = null;
let tessWorker = null;
let tessLoading = false;

const video = document.getElementById('cameraView');
const overlay = document.getElementById('overlay');
const pageList = document.getElementById('pageList');
let pages = []; // { canvas, url, width, height, ocrWords }

/* OpenCV ready handler */
function onOpenCvReady(){ cvReady = true; console.log('OpenCV ready'); }
if(window.cv && cv['onRuntimeInitialized']) cv['onRuntimeInitialized'] = onOpenCvReady;

/* Theme toggle */
const themeToggle = document.getElementById('themeToggle');
const html = document.documentElement;
if(localStorage.theme === 'dark' || (!localStorage.theme && window.matchMedia('(prefers-color-scheme:dark)').matches)) html.dataset.theme = 'dark';
themeToggle.addEventListener('click', ()=> { html.dataset.theme = html.dataset.theme === 'dark' ? 'light' : 'dark'; localStorage.theme = html.dataset.theme; });

/* Resize overlay to video size */
function resizeOverlay(){ overlay.width = video.clientWidth; overlay.height = video.clientHeight; overlay.style.left = video.offsetLeft + 'px'; overlay.style.top = video.offsetTop + 'px'; }
window.addEventListener('resize', resizeOverlay);

/* ------------- Onboarding (first-time guided tooltip) ------------- */
const ONBOARD_KEY = 'pdf_chamber_onboard_done';
const onboard = document.getElementById('onboard');
const onboardNext = document.getElementById('onboardNext');
const onboardPrev = document.getElementById('onboardPrev');
const onboardDone = document.getElementById('onboardDone');
const onboardSkip = document.getElementById('onboardSkip');
const onboardSteps = Array.from(document.querySelectorAll('.onboard-step'));
let onboardIndex = 0;

function showOnboardingIfNeeded(){
  try {
    if(localStorage.getItem(ONBOARD_KEY)) return;
    onboard.style.display = 'flex';
    updateOnboardUI();
  } catch(e) { console.warn('onboard localStorage error', e); onboard.style.display = 'flex'; updateOnboardUI(); }
}
function updateOnboardUI(){
  onboardSteps.forEach((s,i)=> s.classList.toggle('active', i===onboardIndex));
  onboardPrev.style.display = onboardIndex>0 ? 'inline-block' : 'none';
  onboardNext.style.display = onboardIndex < onboardSteps.length-1 ? 'inline-block' : 'none';
  onboardDone.style.display = onboardIndex === onboardSteps.length-1 ? 'inline-block' : 'none';
}
onboardNext.addEventListener('click', ()=> { onboardIndex = Math.min(onboardSteps.length-1, onboardIndex+1); updateOnboardUI(); });
onboardPrev.addEventListener('click', ()=> { onboardIndex = Math.max(0, onboardIndex-1); updateOnboardUI(); });
onboardDone.addEventListener('click', ()=> { localStorage.setItem(ONBOARD_KEY, '1'); onboard.style.display = 'none'; });
onboardSkip.addEventListener('click', ()=> { localStorage.setItem(ONBOARD_KEY, '1'); onboard.style.display = 'none'; });

/* Run onboarding check after small delay so layout finishes */
setTimeout(showOnboardingIfNeeded, 800);

/* ------------- Camera & edge detection ------------- */
document.getElementById('startCam').addEventListener('click', async ()=> {
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal:1280 }, height: { ideal:720 } }, audio:false });
    video.srcObject = stream; await video.play(); resizeOverlay(); startEdgeLoop();
  } catch(err) { alert('Camera error: ' + err.message); }
});

let autoCapture = true;
document.getElementById('modeToggle').addEventListener('click', ()=> {
  autoCapture = !autoCapture;
  document.getElementById('modeToggle').textContent = 'Auto-Capture: ' + (autoCapture ? 'On' : 'Off');
});

/* file upload wiring */
document.getElementById('uploadLabel').addEventListener('click', ()=> document.getElementById('fileInput').click());
document.getElementById('fileInput').addEventListener('change', async (e) => {
  for(const f of e.target.files){
    const url = URL.createObjectURL(f);
    await handleImageUpload(url);
    URL.revokeObjectURL(url);
  }
});

/* edge detection loop (downscaled for speed) */
async function startEdgeLoop(){
  if(!cvReady) return;
  const off = document.createElement('canvas'); const oW = 320, oH = 240; off.width = oW; off.height = oH;
  const offCtx = off.getContext('2d'); const ctx = overlay.getContext('2d');
  processing = false; stabilityCounter = 0; lastContour = null;
  const loop = async () => {
    if(!video.videoWidth){ requestAnimationFrame(loop); return; }
    try {
      offCtx.drawImage(video, 0, 0, oW, oH);
      let src = cv.imread(off);
      let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      let edged = new cv.Mat(); cv.Canny(gray, edged, 75, 200);
      let contours = new cv.MatVector(); let hierarchy = new cv.Mat();
      cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best = null, maxA = 0;
      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i);
        const peri = cv.arcLength(cnt, true);
        const approx = new cv.Mat(); cv.approxPolyDP(cnt, approx, 0.02*peri, true);
        if(approx.rows === 4){
          const area = cv.contourArea(cnt);
          if(area > maxA){ maxA = area; best = approx; }
        }
      }
      ctx.clearRect(0,0,overlay.width, overlay.height);
      if(best){
        const pts = [];
        for(let i=0;i<4;i++) pts.push({ x: best.data32S[i*2] * (overlay.width/oW), y: best.data32S[i*2+1] * (overlay.height/oH) });
        drawPolygon(ctx, pts, 'lime');
        const polyStr = JSON.stringify(pts.map(p => Math.round(p.x) + ',' + Math.round(p.y)));
        if(polyStr === lastContour) stabilityCounter++; else { stabilityCounter = 0; lastContour = polyStr; }
        if(autoCapture && stabilityCounter > 6 && !processing){ processing = true; setTimeout(()=> captureFromVideo(), 120); }
      }
      src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete(); if(best) best.delete();
    } catch(err) { console.warn('edge loop', err); }
    requestAnimationFrame(loop);
  };
  requestAnimationFrame(loop);
}

function drawPolygon(ctx, pts, color){
  ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.closePath(); ctx.stroke(); ctx.fillStyle='rgba(0,255,0,0.06)'; ctx.fill();
}

/* ------------- Capture flow ------------- */
document.getElementById('captureBtn').addEventListener('click', ()=> captureFromVideo());

async function captureFromVideo(){
  if(!video.videoWidth) return;
  const c = document.createElement('canvas'); c.width = video.videoWidth; c.height = video.videoHeight;
  c.getContext('2d').drawImage(video, 0, 0, c.width, c.height);

  // try high-res auto-crop using OpenCV
  if(cvReady){
    try {
      const src = cv.imread(c);
      let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      let edged = new cv.Mat(); cv.Canny(gray, edged, 75, 200);
      let contours = new cv.MatVector(); let hierarchy = new cv.Mat();
      cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best = null, maxA = 0;
      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i); const peri = cv.arcLength(cnt, true); const approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02*peri, true);
        if(approx.rows === 4){
          const area = cv.contourArea(cnt);
          if(area > maxA){ maxA = area; best = approx; }
        }
      }
      if(best){
        const pts = []; for(let i=0;i<4;i++) pts.push({ x: best.data32S[i*2], y: best.data32S[i*2+1] });
        pts.sort((a,b)=>a.y-b.y);
        const top = pts.slice(0,2).sort((a,b)=>a.x-b.x);
        const bottom = pts.slice(2,4).sort((a,b)=>a.x-b.x);
        const ordered = [ top[0], top[1], bottom[1], bottom[0] ];
        const widthTop = Math.hypot(ordered[0].x-ordered[1].x, ordered[0].y-ordered[1].y);
        const widthBottom = Math.hypot(ordered[3].x-ordered[2].x, ordered[3].y-ordered[2].y);
        const maxW = Math.max(widthTop, widthBottom);
        const heightLeft = Math.hypot(ordered[0].x-ordered[3].x, ordered[0].y-ordered[3].y);
        const heightRight = Math.hypot(ordered[1].x-ordered[2].x, ordered[1].y-ordered[2].y);
        const maxH = Math.max(heightLeft, heightRight);

        const srcCoords = cv.matFromArray(4,1,cv.CV_32FC2, [ ordered[0].x, ordered[0].y, ordered[1].x, ordered[1].y, ordered[2].x, ordered[2].y, ordered[3].x, ordered[3].y ]);
        const dstCoords = cv.matFromArray(4,1,cv.CV_32FC2, [ 0,0, maxW-1,0, maxW-1, maxH-1, 0, maxH-1 ]);
        const M = cv.getPerspectiveTransform(srcCoords, dstCoords);
        const dst = new cv.Mat(); const dsize = new cv.Size(Math.round(maxW), Math.round(maxH));
        cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
        const outCanvas = document.createElement('canvas'); outCanvas.width = dst.cols; outCanvas.height = dst.rows; cv.imshow(outCanvas, dst);
        showCropModal(outCanvas.toDataURL('image/jpeg'));
        src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete(); if(best) best.delete(); srcCoords.delete(); dstCoords.delete(); M.delete(); dst.delete();
        return;
      }
      src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete();
    } catch(err) { console.warn('auto-crop failed', err); }
  }

  showCropModal(c.toDataURL('image/jpeg'));
}

/* ------------- Cropper modal ------------- */
const cropModal = document.getElementById('cropModal');
const cropImage = document.getElementById('cropImage');

function showCropModal(dataUrl){
  cropImage.src = dataUrl;
  cropModal.classList.add('show');
  setTimeout(()=>{ if(cropper) cropper.destroy(); cropper = new Cropper(cropImage, { viewMode:1, autoCropArea:1, background:false, responsive:true, movable:true, zoomable:true, rotatable:true }); }, 150);
}

document.getElementById('retakeBtn').addEventListener('click', ()=> { cropModal.classList.remove('show'); if(cropper){ cropper.destroy(); cropper=null; } });

async function finalizeCropAndAdd(){
  if(!cropper) return;
  const c = cropper.getCroppedCanvas();
  const processed = await applyEnhancementsToCanvas(c);

  let ocrWords = null;
  if(document.getElementById('searchablePdf').checked){
    try { ocrWords = await doClientOCR(processed); } catch(err){ console.warn('OCR failed', err); ocrWords = null; }
  }

  pages.push({ canvas: processed, url: processed.toDataURL('image/jpeg', parseFloat(document.getElementById('jpegQuality').value)), width: processed.width, height: processed.height, ocrWords });
  renderPages();
  cropModal.classList.remove('show');
  if(cropper){ cropper.destroy(); cropper = null; }
  document.getElementById('scanNext').disabled = false;
  document.getElementById('generatePdf').disabled = false;
  document.getElementById('exportBtn').disabled = false;
}

document.getElementById('confirmCrop').addEventListener('click', finalizeCropAndAdd);
document.getElementById('scanNextModal').addEventListener('click', async ()=>{ await finalizeCropAndAdd(); cropModal.classList.remove('show'); startEdgeLoop(); });
document.getElementById('generateModal').addEventListener('click', async ()=>{ await finalizeCropAndAdd(); generatePDF(); });

/* ------------- Enhancements (filters/brightness/contrast/deskew/shadow) ------------- */
async function applyEnhancementsToCanvas(srcCanvas){
  const tmp = document.createElement('canvas'); tmp.width = srcCanvas.width; tmp.height = srcCanvas.height;
  const ctx = tmp.getContext('2d'); ctx.drawImage(srcCanvas, 0, 0);

  if(document.getElementById('shadowRemove').checked){
    const imgd = ctx.getImageData(0,0,tmp.width,tmp.height); const d = imgd.data;
    for(let i=0;i<d.length;i+=4){ d[i]=Math.pow(d[i]/255,0.9)*255; d[i+1]=Math.pow(d[i+1]/255,0.9)*255; d[i+2]=Math.pow(d[i+2]/255,0.9)*255; }
    ctx.putImageData(imgd, 0, 0);
  }

  if(document.getElementById('autoEnhance').classList.contains('active')){
    const imgd = ctx.getImageData(0,0,tmp.width,tmp.height); const d = imgd.data;
    let min=255, max=0;
    for(let i=0;i<d.length;i+=4){ const v = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]; if(v<min) min=v; if(v>max) max=v; }
    const scale = 255/(max-min || 1);
    for(let i=0;i<d.length;i+=4){ d[i]=Math.max(0,Math.min(255,Math.round((d[i]-min)*scale))); d[i+1]=Math.max(0,Math.min(255,Math.round((d[i+1]-min)*scale))); d[i+2]=Math.max(0,Math.min(255,Math.round((d[i+2]-min)*scale))); }
    ctx.putImageData(imgd, 0, 0);
  }

  const activeFilter = document.querySelector('.filter-btn.active')?.dataset.filter || 'original';
  if(activeFilter !== 'original'){
    const imgd = ctx.getImageData(0,0,tmp.width,tmp.height); const d = imgd.data;
    for(let i=0;i<d.length;i+=4){
      let r=d[i], g=d[i+1], b=d[i+2];
      if(activeFilter === 'gray'){ const v = 0.299*r + 0.587*g + 0.114*b; r=g=b=v; }
      else if(activeFilter === 'binarize'){ const v = 0.299*r + 0.587*g + 0.114*b; const t=128; r=g=b = (v>t?255:0); }
      else if(activeFilter === 'light'){ const v=0.299*r + 0.587*g + 0.114*b; r=g=b = v * 1.15; }
      else if(activeFilter === 'auto'){ r=(r-128)*1.05+128; g=(g-128)*1.05+128; b=(b-128)*1.05+128; }
      d[i]=Math.max(0,Math.min(255,Math.round(r))); d[i+1]=Math.max(0,Math.min(255,Math.round(g))); d[i+2]=Math.max(0,Math.min(255,Math.round(b)));
    }
    ctx.putImageData(imgd, 0, 0);
  }

  const bright = parseInt(document.getElementById('brightness').value)/100;
  const cont = parseInt(document.getElementById('contrast').value)/100;
  if(bright !== 1 || cont !== 1){
    const imgd = ctx.getImageData(0,0,tmp.width,tmp.height); const d = imgd.data;
    for(let i=0;i<d.length;i+=4){
      let r=d[i], g=d[i+1], b=d[i+2];
      r = (r - 128) * cont + 128; g = (g - 128) * cont + 128; b = (b - 128) * cont + 128;
      r *= bright; g *= bright; b *= bright;
      d[i] = Math.max(0, Math.min(255, Math.round(r))); d[i+1] = Math.max(0, Math.min(255, Math.round(g))); d[i+2] = Math.max(0, Math.min(255, Math.round(b)));
    }
    ctx.putImageData(imgd, 0, 0);
  }

  if(document.getElementById('deskew').checked && cvReady){
    try{
      const mCanvas = document.createElement('canvas'); mCanvas.width = tmp.width; mCanvas.height = tmp.height; mCanvas.getContext('2d').drawImage(tmp,0,0);
      let src = cv.imread(mCanvas); let gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
      cv.threshold(gray,gray,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU);
      let lines = new cv.Mat(); cv.HoughLinesP(gray,lines,1,Math.PI/180,100,Math.min(tmp.width,tmp.height)/4,10);
      let angle=0,count=0;
      for(let i=0;i<lines.rows;i++){ let x1=lines.data32S[i*4], y1=lines.data32S[i*4+1], x2=lines.data32S[i*4+2], y2=lines.data32S[i*4+3]; let a=Math.atan2(y2-y1,x2-x1); angle+=a; count++; }
      if(count>0){ angle = angle/count; const deg = angle * 180 / Math.PI;
        const off=document.createElement('canvas'); off.width=tmp.width; off.height=tmp.height;
        const octx = off.getContext('2d'); octx.translate(tmp.width/2,tmp.height/2); octx.rotate(-deg * Math.PI/180); octx.drawImage(tmp, -tmp.width/2, -tmp.height/2);
        tmp.width = off.width; tmp.height = off.height; tmp.getContext('2d').drawImage(off,0,0);
      }
      src.delete(); gray.delete(); lines.delete();
    } catch(err){ console.warn('deskew failed', err); }
  }

  return tmp;
}

/* ------------- Client OCR (Tesseract) ------------- */
async function ensureTesseractWorker(){
  if(tessWorker) return tessWorker;
  if(tessLoading){
    while(tessLoading && !tessWorker) await new Promise(r => setTimeout(r, 200));
    return tessWorker;
  }
  tessLoading = true;
  tessWorker = Tesseract.createWorker(TESS_OPTIONS);
  try {
    await tessWorker.load();
    await tessWorker.loadLanguage(TESS_LANGS);
    await tessWorker.initialize(TESS_LANGS);
    tessLoading = false;
    return tessWorker;
  } catch(err){
    tessLoading = false;
    tessWorker = null;
    console.error('Tesseract init failed', err);
    throw err;
  }
}

async function doClientOCR(canvas){
  const worker = await ensureTesseractWorker();
  const result = await worker.recognize(canvas.toDataURL('image/jpeg'));
  const words = (result?.data?.words || []).map(w => ({
    text: w.text,
    bbox: { x0: w.bbox.x0, y0: w.bbox.y0, x1: w.bbox.x1, y1: w.bbox.y1 },
    confidence: w.confidence
  }));
  return words;
}

/* ------------- Pages UI & Sortable ------------- */
function renderPages(){
  pageList.innerHTML = '';
  pages.forEach((p, i) => {
    const div = document.createElement('div'); div.className = 'thumb'; div.dataset.index = i;
    const canvas = document.createElement('canvas'); canvas.width = p.canvas.width; canvas.height = p.canvas.height;
    canvas.getContext('2d').drawImage(p.canvas, 0, 0); canvas.style.width = '110px';
    const info = document.createElement('div'); info.style.marginLeft = '8px'; info.innerHTML = `<div style="font-weight:600">Page ${i+1}</div><div class="small">${p.width}×${p.height}</div>`;
    const actions = document.createElement('div'); actions.style.marginLeft='auto'; actions.style.display='flex'; actions.style.flexDirection='column'; actions.style.gap='6px';
    const edit = document.createElement('button'); edit.className='btn'; edit.textContent='Edit'; edit.addEventListener('click', ()=> showCropModal(p.canvas.toDataURL('image/jpeg')));
    const del = document.createElement('button'); del.className='btn'; del.textContent='Delete'; del.addEventListener('click', ()=> { pages.splice(i,1); renderPages(); });
    actions.appendChild(edit); actions.appendChild(del);
    div.appendChild(canvas); div.appendChild(info); div.appendChild(actions);
    pageList.appendChild(div);
  });

  Sortable.create(pageList, {
    animation: 150,
    onEnd: (evt) => {
      const item = pages.splice(evt.oldIndex, 1)[0];
      pages.splice(evt.newIndex, 0, item);
      renderPages();
    }
  });
}

/* ------------- Generate searchable PDF (pdf-lib) ------------- */
async function generatePDF(){
  if(pages.length === 0) return alert('No pages to export');
  const pdfDoc = await PDFLib.PDFDocument.create();
  const font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
  const pdfSize = document.getElementById('pdfSize').value;
  for(const p of pages){
    const dataUrl = p.canvas.toDataURL('image/jpeg', parseFloat(document.getElementById('jpegQuality').value));
    const bytes = await (await fetch(dataUrl)).arrayBuffer();
    const img = await pdfDoc.embedJpg(bytes);
    let page;
    if(pdfSize === 'A4') {
      page = pdfDoc.addPage([595, 842]);
      const ratio = Math.min(595 / p.canvas.width, 842 / p.canvas.height);
      const w = p.canvas.width * ratio, h = p.canvas.height * ratio;
      page.drawImage(img, { x: (595 - w)/2, y: (842 - h)/2, width: w, height: h });
    } else if(pdfSize === 'Letter') {
      page = pdfDoc.addPage([612, 792]);
      const ratio = Math.min(612 / p.canvas.width, 792 / p.canvas.height);
      const w = p.canvas.width * ratio, h = p.canvas.height * ratio;
      page.drawImage(img, { x: (612 - w)/2, y: (792 - h)/2, width: w, height: h });
    } else {
      page = pdfDoc.addPage([p.canvas.width, p.canvas.height]);
      page.drawImage(img, { x:0, y:0, width: p.canvas.width, height: p.canvas.height });
    }

    if(p.ocrWords && p.ocrWords.length){
      const scaleX = page.getWidth() / p.canvas.width;
      const scaleY = page.getHeight() / p.canvas.height;
      for(const w of p.ocrWords){
        const x = w.bbox.x0 * scaleX;
        const y = page.getHeight() - (w.bbox.y1 * scaleY);
        page.drawText(w.text.replace(/\s+/g,' '), { x, y, size: 10, font, color: PDFLib.rgb(1,1,1), opacity: 0 });
      }
    }
  }

  const pdfBytes = await pdfDoc.save();
  const blob = new Blob([pdfBytes], { type: 'application/pdf' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url;
  a.download = `scanned-${new Date().toISOString().slice(0,10)}.pdf`; a.click();
  setTimeout(()=> URL.revokeObjectURL(url), 2000);
}

/* ------------- Save / Load Project (localStorage) ------------- */
document.getElementById('saveProject').addEventListener('click', async ()=>{
  const toSave = await Promise.all(pages.map(async p => ({ dataUrl: p.canvas.toDataURL('image/jpeg', 0.9), width: p.width, height: p.height, ocrWords: p.ocrWords })));
  localStorage.setItem('scanProject', JSON.stringify(toSave));
  alert('Project saved locally');
});
document.getElementById('loadProject').addEventListener('click', async ()=>{
  const raw = localStorage.getItem('scanProject'); if(!raw) return alert('No saved project');
  const arr = JSON.parse(raw); pages = [];
  for(const it of arr){ const img = new Image(); img.src = it.dataUrl; await new Promise(r=>img.onload=r); const c = document.createElement('canvas'); c.width = it.width; c.height = it.height; c.getContext('2d').drawImage(img,0,0); pages.push({ canvas: c, url: it.dataUrl, width: it.width, height: it.height, ocrWords: it.ocrWords }); }
  renderPages(); alert('Project loaded');
});

/* ------------- Upload helper (auto-crop uploaded images) ------------- */
async function handleImageUpload(url){
  const img = new Image(); img.crossOrigin = 'anonymous'; img.src = url; await new Promise(r=>img.onload=r);
  const c = document.createElement('canvas'); c.width = img.naturalWidth; c.height = img.naturalHeight; c.getContext('2d').drawImage(img,0,0);
  if(cvReady){
    try{
      const src = cv.imread(c); let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); cv.GaussianBlur(gray, gray, new cv.Size(5,5), 0);
      let edged = new cv.Mat(); cv.Canny(gray, edged, 75, 200);
      let contours = new cv.MatVector(); let hierarchy = new cv.Mat(); cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let best = null, maxA = 0;
      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i); const peri = cv.arcLength(cnt, true); const approx = new cv.Mat(); cv.approxPolyDP(cnt, approx, 0.02*peri, true);
        if(approx.rows === 4){
          const area = cv.contourArea(cnt); if(area > maxA){ maxA = area; best = approx; }
        }
      }
      if(best){
        const pts = []; for(let i=0;i<4;i++) pts.push({ x: best.data32S[i*2], y: best.data32S[i*2+1] });
        pts.sort((a,b)=>a.y-b.y); const top = pts.slice(0,2).sort((a,b)=>a.x-b.x); const bottom = pts.slice(2,4).sort((a,b)=>a.x-b.x);
        const ordered = [ top[0], top[1], bottom[1], bottom[0] ];
        const widthTop = Math.hypot(ordered[0].x-ordered[1].x, ordered[0].y-ordered[1].y);
        const widthBottom = Math.hypot(ordered[3].x-ordered[2].x, ordered[3].y-ordered[2].y);
        const maxW = Math.max(widthTop, widthBottom);
        const heightLeft = Math.hypot(ordered[0].x-ordered[3].x, ordered[0].y-ordered[3].y);
        const heightRight = Math.hypot(ordered[1].x-ordered[2].x, ordered[1].y-ordered[2].y);
        const maxH = Math.max(heightLeft, heightRight);
        const srcCoords = cv.matFromArray(4,1,cv.CV_32FC2, [ ordered[0].x, ordered[0].y, ordered[1].x, ordered[1].y, ordered[2].x, ordered[2].y, ordered[3].x, ordered[3].y ]);
        const dstCoords = cv.matFromArray(4,1,cv.CV_32FC2, [ 0,0, maxW-1,0, maxW-1, maxH-1, 0, maxH-1 ]);
        const M = cv.getPerspectiveTransform(srcCoords, dstCoords);
        const dst = new cv.Mat(); const dsize = new cv.Size(Math.round(maxW), Math.round(maxH));
        cv.warpPerspective(src, dst, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
        const outCanvas = document.createElement('canvas'); outCanvas.width = dst.cols; outCanvas.height = dst.rows; cv.imshow(outCanvas, dst);
        showCropModal(outCanvas.toDataURL('image/jpeg'));
        src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete(); if(best) best.delete(); srcCoords.delete(); dstCoords.delete(); M.delete(); dst.delete();
        return;
      }
      src.delete(); gray.delete(); edged.delete(); contours.delete(); hierarchy.delete();
    } catch(err){ console.warn('upload auto-crop failed', err); }
  }
  showCropModal(c.toDataURL('image/jpeg'));
}

/* ------------- Misc UI wiring ------------- */
document.getElementById('scanNext').addEventListener('click', async ()=> { await finalizeCropAndAdd(); });
document.getElementById('exportBtn').addEventListener('click', generatePDF);
document.getElementById('generatePdf').addEventListener('click', generatePDF);
document.getElementById('clearAll').addEventListener('click', ()=> { pages = []; renderPages(); document.getElementById('exportBtn').disabled = true; document.getElementById('generatePdf').disabled = true; });

document.querySelectorAll('.filter-btn').forEach(btn => btn.addEventListener('click', ()=> {
  document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
}));
document.getElementById('autoEnhance').addEventListener('click', e => e.target.classList.toggle('active'));

/* ------------- End of script ------------- */
</script>
</body>
</html>
